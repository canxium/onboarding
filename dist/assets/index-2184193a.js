import{_ as se,g as ge}from"./index-3c0dfeec.js";class Q extends Error{constructor(j){super(j.message),this.message=j.message,this.code=j.code,this.data=j.data}}const ye=(x,j)=>{let k;x.request?k=x.request.bind(x):x.sendAsync&&(k=be(x));const O=async({method:A,params:$})=>{const v=A;if(j&&j[v]===null)throw new Q({code:4200,message:`The Provider does not support the requested method: ${A}`});if(j&&j[v])return j[v]({baseRequest:k,params:$});if(k)return k({method:A,params:$});throw new Q({code:4200,message:`The Provider does not support the requested method: ${A}`})};return x.request=O,x},be=x=>({method:j,params:k})=>new Promise((O,A)=>{x.sendAsync({id:0,jsonrpc:"2.0",method:j,params:k},($,{result:v})=>{$?A(JSON.parse($)):O(v??null)})}),ve=`
@font-face {
  font-family: 'Inter';
  font-style:  normal;
  font-weight: 300 600;
  font-display: swap;
  src: url("https://rsms.me/inter/font-files/InterVariable.woff2") format("woff2-variations");
}
`;function ee(x,{strict:j=!0}={}){return!x||typeof x!="string"?!1:j?/^0x[0-9a-fA-F]*$/.test(x):x.startsWith("0x")}function ne(x){return ee(x,{strict:!1})?Math.ceil((x.length-2)/2):x.length}const _e="2.12.0",Qe=x=>x,Xe=x=>x,we=()=>`viem@${_e}`;class F extends Error{constructor(j,k={}){var $;super(),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ViemError"}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:we()});const O=k.cause instanceof F?k.cause.details:($=k.cause)!=null&&$.message?k.cause.message:k.details,A=k.cause instanceof F&&k.cause.docsPath||k.docsPath;this.message=[j||"An error occurred.","",...k.metaMessages?[...k.metaMessages,""]:[],...A?[`Docs: https://viem.sh${A}${k.docsSlug?`#${k.docsSlug}`:""}`]:[],...O?[`Details: ${O}`]:[],`Version: ${this.version}`].join(`
`),k.cause&&(this.cause=k.cause),this.details=O,this.docsPath=A,this.metaMessages=k.metaMessages,this.shortMessage=j}walk(j){return ie(this,j)}}function ie(x,j){return j!=null&&j(x)?x:x&&typeof x=="object"&&"cause"in x?ie(x.cause,j):j?null:x}class et extends F{constructor({offset:j,position:k,size:O}){super(`Slice ${k==="start"?"starting":"ending"} at offset "${j}" is out-of-bounds (size: ${O}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SliceOffsetOutOfBoundsError"})}}class oe extends F{constructor({size:j,targetSize:k,type:O}){super(`${O.charAt(0).toUpperCase()}${O.slice(1).toLowerCase()} size (${j}) exceeds padding size (${k}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SizeExceedsPaddingSizeError"})}}class tt extends F{constructor({size:j,targetSize:k,type:O}){super(`${O.charAt(0).toUpperCase()}${O.slice(1).toLowerCase()} is expected to be ${k} ${O} long, but is ${j} ${O} long.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidBytesLengthError"})}}function H(x,{dir:j,size:k=32}={}){return typeof x=="string"?$e(x,{dir:j,size:k}):xe(x,{dir:j,size:k})}function $e(x,{dir:j,size:k=32}={}){if(k===null)return x;const O=x.replace("0x","");if(O.length>k*2)throw new oe({size:Math.ceil(O.length/2),targetSize:k,type:"hex"});return`0x${O[j==="right"?"padEnd":"padStart"](k*2,"0")}`}function xe(x,{dir:j,size:k=32}={}){if(k===null)return x;if(x.length>k)throw new oe({size:x.length,targetSize:k,type:"bytes"});const O=new Uint8Array(k);for(let A=0;A<k;A++){const $=j==="right";O[$?A:k-A-1]=x[$?A:x.length-A-1]}return O}class je extends F{constructor({max:j,min:k,signed:O,size:A,value:$}){super(`Number "${$}" is not in safe ${A?`${A*8}-bit ${O?"signed":"unsigned"} `:""}integer range ${j?`(${k} to ${j})`:`(above ${k})`}`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"IntegerOutOfRangeError"})}}class rt extends F{constructor(j){super(`Bytes value "${j}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidBytesBooleanError"})}}class ke extends F{constructor(j){super(`Hex value "${j}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidHexBooleanError"})}}class st extends F{constructor(j){super(`Hex value "${j}" is an odd length (${j.length}). It must be an even length.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidHexValueError"})}}class Ae extends F{constructor({givenSize:j,maxSize:k}){super(`Size cannot exceed ${k} bytes. Given size: ${j} bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SizeOverflowError"})}}function Z(x,{dir:j="left"}={}){let k=typeof x=="string"?x.replace("0x",""):x,O=0;for(let A=0;A<k.length-1&&k[j==="left"?A:k.length-A-1].toString()==="0";A++)O++;return k=j==="left"?k.slice(O):k.slice(0,k.length-O),typeof x=="string"?(k.length===1&&j==="right"&&(k=`${k}0`),`0x${k.length%2===1?`0${k}`:k}`):k}function V(x,{size:j}){if(ne(x)>j)throw new Ae({givenSize:ne(x),maxSize:j})}function K(x,j){const k=typeof j=="string"?{to:j}:j,O=k.to;return O==="number"?Re(x,k):O==="bigint"?te(x,k):O==="string"?Oe(x,k):O==="boolean"?Se(x,k):Y(x,k)}function te(x,j={}){const{signed:k}=j;j.size&&V(x,{size:j.size});const O=BigInt(x);if(!k)return O;const A=(x.length-2)/2,$=(1n<<BigInt(A)*8n-1n)-1n;return O<=$?O:O-BigInt(`0x${"f".padStart(A*2,"f")}`)-1n}function Se(x,j={}){let k=x;if(j.size&&(V(k,{size:j.size}),k=Z(k)),Z(k)==="0x00")return!1;if(Z(k)==="0x01")return!0;throw new ke(k)}function Re(x,j={}){return Number(te(x,j))}function Oe(x,j={}){let k=Y(x);return j.size&&(V(k,{size:j.size}),k=Z(k,{dir:"right"})),new TextDecoder().decode(k)}const Ee=Array.from({length:256},(x,j)=>j.toString(16).padStart(2,"0"));function Ie(x,j={}){return typeof x=="number"||typeof x=="bigint"?re(x,j):typeof x=="string"?Te(x,j):typeof x=="boolean"?De(x,j):le(x,j)}function De(x,j={}){const k=`0x${Number(x)}`;return typeof j.size=="number"?(V(k,{size:j.size}),H(k,{size:j.size})):k}function le(x,j={}){let k="";for(let A=0;A<x.length;A++)k+=Ee[x[A]];const O=`0x${k}`;return typeof j.size=="number"?(V(O,{size:j.size}),H(O,{dir:"right",size:j.size})):O}function re(x,j={}){const{signed:k,size:O}=j,A=BigInt(x);let $;O?k?$=(1n<<BigInt(O)*8n-1n)-1n:$=2n**(BigInt(O)*8n)-1n:typeof x=="number"&&($=BigInt(Number.MAX_SAFE_INTEGER));const v=typeof $=="bigint"&&k?-$-1n:0;if($&&A>$||A<v){const p=typeof x=="bigint"?"n":"";throw new je({max:$?`${$}${p}`:void 0,min:`${v}${p}`,signed:k,size:O,value:`${x}${p}`})}const l=`0x${(k&&A<0?(1n<<BigInt(O*8))+BigInt(A):A).toString(16)}`;return O?H(l,{size:O}):l}const Ce=new TextEncoder;function Te(x,j={}){const k=Ce.encode(x);return le(k,j)}const Ne=new TextEncoder;function nt(x,j={}){return typeof x=="number"||typeof x=="bigint"?ze(x,j):typeof x=="boolean"?Me(x,j):ee(x)?Y(x,j):Le(x,j)}function Me(x,j={}){const k=new Uint8Array(1);return k[0]=Number(x),typeof j.size=="number"?(V(k,{size:j.size}),H(k,{size:j.size})):k}const B={zero:48,nine:57,A:65,F:70,a:97,f:102};function ae(x){if(x>=B.zero&&x<=B.nine)return x-B.zero;if(x>=B.A&&x<=B.F)return x-(B.A-10);if(x>=B.a&&x<=B.f)return x-(B.a-10)}function Y(x,j={}){let k=x;j.size&&(V(k,{size:j.size}),k=H(k,{dir:"right",size:j.size}));let O=k.slice(2);O.length%2&&(O=`0${O}`);const A=O.length/2,$=new Uint8Array(A);for(let v=0,l=0;v<A;v++){const p=ae(O.charCodeAt(l++)),y=ae(O.charCodeAt(l++));if(p===void 0||y===void 0)throw new F(`Invalid byte sequence ("${O[l-2]}${O[l-1]}" in "${O}").`);$[v]=p*16+y}return $}function ze(x,j){const k=re(x,j);return Y(k)}function Le(x,j={}){const k=Ne.encode(x);return typeof j.size=="number"?(V(k,{size:j.size}),H(k,{dir:"right",size:j.size})):k}const ce={gwei:9,wei:18},at={ether:-9,wei:9},it={ether:-18,gwei:-9};function Pe(x,j){let k=x.toString();const O=k.startsWith("-");O&&(k=k.slice(1)),k=k.padStart(j,"0");let[A,$]=[k.slice(0,k.length-j),k.slice(k.length-j)];return $=$.replace(/(0+)$/,""),`${O?"-":""}${A||"0"}${$?`.${$}`:""}`}function ue(x,j="wei"){return Pe(x,ce[j])}function qe(x,j){let[k,O="0"]=x.split(".");const A=k.startsWith("-");if(A&&(k=k.slice(1)),O=O.replace(/(0+)$/,""),j===0)Math.round(+`.${O}`)===1&&(k=`${BigInt(k)+1n}`),O="";else if(O.length>j){const[$,v,l]=[O.slice(0,j-1),O.slice(j-1,j),O.slice(j)],p=Math.round(+`${v}.${l}`);p>9?O=`${BigInt($)+BigInt(1)}0`.padStart($.length+1,"0"):O=`${$}${p}`,O.length>j&&(O=O.slice(1),k=`${BigInt(k)+1n}`),O=O.slice(0,j)}else O=O.padEnd(j,"0");return BigInt(`${A?"-":""}${k}${O}`)}function me(x,j="wei"){return qe(x,ce[j])}const fe=x=>fe(),Fe=x=>{const j=te(x);return ue(j)},Ue=x=>{if(!x)return x;const j=K(x,"bigint");return ue(j)},Be=x=>{if(typeof x!="string"&&typeof x!="number")throw new Error("eth must be a string or number value");const j=typeof x=="number"?x.toString():x;return me(j)},Ve=x=>re(x),He=(x,j)=>j?typeof j=="function"?`Please <a href="#" onclick="${()=>j()}">install</a> or enable to ${x} to continue`:`Please <a href="${j}" target="_blank">install</a> or enable to ${x} to continue`:`Please switch to ${x} to continue`,We=async x=>{const j=await se(()=>import("./index-bc6fb307.js"),["assets/index-bc6fb307.js","assets/number-1d9e222f.js","assets/index-3c0dfeec.js","assets/index-f645abdd.css"]),{id:k,label:O,token:A,publicRpcUrl:$,blockExplorerUrl:v,rpcUrl:l}=x;switch(k){case"0x89":{const{polygon:p}=j;return p}case"0xa":{const{optimism:p}=j;return p}case"0xa4b1":{const{arbitrum:p}=j;return p}case"0x144":{const{zkSync:p}=j;return p}case"0x38":{const{bsc:p}=j;return p}case"0x1":{const{mainnet:p}=j;return p}case"0xaa36a7":{const{sepolia:p}=j;return p}case"0xfa":{const{fantom:p}=j;return p}case"0xa86a":{const{avalanche:p}=j;return p}case"0xa4ec":{const{celo:p}=j;return p}case"0x2105":{const{base:p}=j;return p}case"0x14a33":{const{baseGoerli:p}=j;return p}case"0x64":{const{gnosis:p}=j;return p}case"0x63564C40":{const{harmonyOne:p}=j;return p}case"0x27bc86aa":{const{degen:p}=j;return p}default:{const{extractChain:p,defineChain:y}=await se(()=>import("./index-c372292d.js"),["assets/index-c372292d.js","assets/number-1d9e222f.js","assets/index-3c0dfeec.js","assets/index-f645abdd.css"]),f=p({chains:Object.values(j),id:K(k,"number")});return f||y({id:K(k,"number"),name:O??"",nativeCurrency:{decimals:18,name:A??"",symbol:A??""},rpcUrls:{default:{http:[l??"",$??""]}},blockExplorers:{default:{name:"Explorer",url:v??""}}})}}};var X;(function(x){x[x.ACCOUNT_ACCESS_REJECTED=4001]="ACCOUNT_ACCESS_REJECTED",x[x.ACCOUNT_ACCESS_ALREADY_REQUESTED=-32002]="ACCOUNT_ACCESS_ALREADY_REQUESTED",x[x.UNAUTHORIZED=4100]="UNAUTHORIZED",x[x.INVALID_PARAMS=-32602]="INVALID_PARAMS",x[x.UNSUPPORTED_METHOD=4200]="UNSUPPORTED_METHOD",x[x.DISCONNECTED=4900]="DISCONNECTED",x[x.CHAIN_DISCONNECTED=4901]="CHAIN_DISCONNECTED",x[x.CHAIN_NOT_ADDED=4902]="CHAIN_NOT_ADDED",x[x.DOES_NOT_EXIST=-32601]="DOES_NOT_EXIST",x[x.UNRECOGNIZED_CHAIN_ID=-32603]="UNRECOGNIZED_CHAIN_ID"})(X||(X={}));var he={exports:{}};(function(x,j){(function(k,O){x.exports=O()})(self,()=>{return k={7629:(A,$,v)=>{const l=v(375),p=v(8571),y=v(9474),f=v(1687),t=v(8652),n=v(8160),i=v(3292),s=v(6354),e=v(8901),o=v(9708),r=v(6914),a=v(2294),c=v(6133),m=v(1152),g=v(8863),_=v(2036),b={Base:class{constructor(u){this.type=u,this.$_root=null,this._definition={},this._reset()}_reset(){this._ids=new a.Ids,this._preferences=null,this._refs=new c.Manager,this._cache=null,this._valids=null,this._invalids=null,this._flags={},this._rules=[],this._singleRules=new Map,this.$_terms={},this.$_temp={ruleset:null,whens:{}}}describe(){return l(typeof o.describe=="function","Manifest functionality disabled"),o.describe(this)}allow(){for(var u=arguments.length,h=new Array(u),d=0;d<u;d++)h[d]=arguments[d];return n.verifyFlat(h,"allow"),this._values(h,"_valids")}alter(u){l(u&&typeof u=="object"&&!Array.isArray(u),"Invalid targets argument"),l(!this._inRuleset(),"Cannot set alterations inside a ruleset");const h=this.clone();h.$_terms.alterations=h.$_terms.alterations||[];for(const d in u){const w=u[d];l(typeof w=="function","Alteration adjuster for",d,"must be a function"),h.$_terms.alterations.push({target:d,adjuster:w})}return h.$_temp.ruleset=!1,h}artifact(u){return l(u!==void 0,"Artifact cannot be undefined"),l(!this._cache,"Cannot set an artifact with a rule cache"),this.$_setFlag("artifact",u)}cast(u){return l(u===!1||typeof u=="string","Invalid to value"),l(u===!1||this._definition.cast[u],"Type",this.type,"does not support casting to",u),this.$_setFlag("cast",u===!1?void 0:u)}default(u,h){return this._default("default",u,h)}description(u){return l(u&&typeof u=="string","Description must be a non-empty string"),this.$_setFlag("description",u)}empty(u){const h=this.clone();return u!==void 0&&(u=h.$_compile(u,{override:!1})),h.$_setFlag("empty",u,{clone:!1})}error(u){return l(u,"Missing error"),l(u instanceof Error||typeof u=="function","Must provide a valid Error object or a function"),this.$_setFlag("error",u)}example(u){let h=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return l(u!==void 0,"Missing example"),n.assertOptions(h,["override"]),this._inner("examples",u,{single:!0,override:h.override})}external(u,h){return typeof u=="object"&&(l(!h,"Cannot combine options with description"),h=u.description,u=u.method),l(typeof u=="function","Method must be a function"),l(h===void 0||h&&typeof h=="string","Description must be a non-empty string"),this._inner("externals",{method:u,description:h},{single:!0})}failover(u,h){return this._default("failover",u,h)}forbidden(){return this.presence("forbidden")}id(u){return u?(l(typeof u=="string","id must be a non-empty string"),l(/^[^\.]+$/.test(u),"id cannot contain period character"),this.$_setFlag("id",u)):this.$_setFlag("id",void 0)}invalid(){for(var u=arguments.length,h=new Array(u),d=0;d<u;d++)h[d]=arguments[d];return this._values(h,"_invalids")}label(u){return l(u&&typeof u=="string","Label name must be a non-empty string"),this.$_setFlag("label",u)}meta(u){return l(u!==void 0,"Meta cannot be undefined"),this._inner("metas",u,{single:!0})}note(){for(var u=arguments.length,h=new Array(u),d=0;d<u;d++)h[d]=arguments[d];l(h.length,"Missing notes");for(const w of h)l(w&&typeof w=="string","Notes must be non-empty strings");return this._inner("notes",h)}only(){let u=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return l(typeof u=="boolean","Invalid mode:",u),this.$_setFlag("only",u)}optional(){return this.presence("optional")}prefs(u){l(u,"Missing preferences"),l(u.context===void 0,"Cannot override context"),l(u.externals===void 0,"Cannot override externals"),l(u.warnings===void 0,"Cannot override warnings"),l(u.debug===void 0,"Cannot override debug"),n.checkPreferences(u);const h=this.clone();return h._preferences=n.preferences(h._preferences,u),h}presence(u){return l(["optional","required","forbidden"].includes(u),"Unknown presence mode",u),this.$_setFlag("presence",u)}raw(){let u=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return this.$_setFlag("result",u?"raw":void 0)}result(u){return l(["raw","strip"].includes(u),"Unknown result mode",u),this.$_setFlag("result",u)}required(){return this.presence("required")}strict(u){const h=this.clone(),d=u!==void 0&&!u;return h._preferences=n.preferences(h._preferences,{convert:d}),h}strip(){let u=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return this.$_setFlag("result",u?"strip":void 0)}tag(){for(var u=arguments.length,h=new Array(u),d=0;d<u;d++)h[d]=arguments[d];l(h.length,"Missing tags");for(const w of h)l(w&&typeof w=="string","Tags must be non-empty strings");return this._inner("tags",h)}unit(u){return l(u&&typeof u=="string","Unit name must be a non-empty string"),this.$_setFlag("unit",u)}valid(){for(var u=arguments.length,h=new Array(u),d=0;d<u;d++)h[d]=arguments[d];n.verifyFlat(h,"valid");const w=this.allow(...h);return w.$_setFlag("only",!!w._valids,{clone:!1}),w}when(u,h){const d=this.clone();d.$_terms.whens||(d.$_terms.whens=[]);const w=i.when(d,u,h);if(!["any","link"].includes(d.type)){const S=w.is?[w]:w.switch;for(const R of S)l(!R.then||R.then.type==="any"||R.then.type===d.type,"Cannot combine",d.type,"with",R.then&&R.then.type),l(!R.otherwise||R.otherwise.type==="any"||R.otherwise.type===d.type,"Cannot combine",d.type,"with",R.otherwise&&R.otherwise.type)}return d.$_terms.whens.push(w),d.$_mutateRebuild()}cache(u){l(!this._inRuleset(),"Cannot set caching inside a ruleset"),l(!this._cache,"Cannot override schema cache"),l(this._flags.artifact===void 0,"Cannot cache a rule with an artifact");const h=this.clone();return h._cache=u||t.provider.provision(),h.$_temp.ruleset=!1,h}clone(){const u=Object.create(Object.getPrototypeOf(this));return this._assign(u)}concat(u){l(n.isSchema(u),"Invalid schema object"),l(this.type==="any"||u.type==="any"||u.type===this.type,"Cannot merge type",this.type,"with another type:",u.type),l(!this._inRuleset(),"Cannot concatenate onto a schema with open ruleset"),l(!u._inRuleset(),"Cannot concatenate a schema with open ruleset");let h=this.clone();if(this.type==="any"&&u.type!=="any"){const d=u.clone();for(const w of Object.keys(h))w!=="type"&&(d[w]=h[w]);h=d}h._ids.concat(u._ids),h._refs.register(u,c.toSibling),h._preferences=h._preferences?n.preferences(h._preferences,u._preferences):u._preferences,h._valids=_.merge(h._valids,u._valids,u._invalids),h._invalids=_.merge(h._invalids,u._invalids,u._valids);for(const d of u._singleRules.keys())h._singleRules.has(d)&&(h._rules=h._rules.filter(w=>w.keep||w.name!==d),h._singleRules.delete(d));for(const d of u._rules)u._definition.rules[d.method].multi||h._singleRules.set(d.name,d),h._rules.push(d);if(h._flags.empty&&u._flags.empty){h._flags.empty=h._flags.empty.concat(u._flags.empty);const d=Object.assign({},u._flags);delete d.empty,f(h._flags,d)}else if(u._flags.empty){h._flags.empty=u._flags.empty;const d=Object.assign({},u._flags);delete d.empty,f(h._flags,d)}else f(h._flags,u._flags);for(const d in u.$_terms){const w=u.$_terms[d];w?h.$_terms[d]?h.$_terms[d]=h.$_terms[d].concat(w):h.$_terms[d]=w.slice():h.$_terms[d]||(h.$_terms[d]=w)}return this.$_root._tracer&&this.$_root._tracer._combine(h,[this,u]),h.$_mutateRebuild()}extend(u){return l(!u.base,"Cannot extend type with another base"),e.type(this,u)}extract(u){return u=Array.isArray(u)?u:u.split("."),this._ids.reach(u)}fork(u,h){l(!this._inRuleset(),"Cannot fork inside a ruleset");let d=this;for(let w of[].concat(u))w=Array.isArray(w)?w:w.split("."),d=d._ids.fork(w,h,d);return d.$_temp.ruleset=!1,d}rule(u){const h=this._definition;n.assertOptions(u,Object.keys(h.modifiers)),l(this.$_temp.ruleset!==!1,"Cannot apply rules to empty ruleset or the last rule added does not support rule properties");const d=this.$_temp.ruleset===null?this._rules.length-1:this.$_temp.ruleset;l(d>=0&&d<this._rules.length,"Cannot apply rules to empty ruleset");const w=this.clone();for(let S=d;S<w._rules.length;++S){const R=w._rules[S],E=p(R);for(const I in u)h.modifiers[I](E,u[I]),l(E.name===R.name,"Cannot change rule name");w._rules[S]=E,w._singleRules.get(E.name)===R&&w._singleRules.set(E.name,E)}return w.$_temp.ruleset=!1,w.$_mutateRebuild()}get ruleset(){l(!this._inRuleset(),"Cannot start a new ruleset without closing the previous one");const u=this.clone();return u.$_temp.ruleset=u._rules.length,u}get $(){return this.ruleset}tailor(u){u=[].concat(u),l(!this._inRuleset(),"Cannot tailor inside a ruleset");let h=this;if(this.$_terms.alterations)for(const{target:d,adjuster:w}of this.$_terms.alterations)u.includes(d)&&(h=w(h),l(n.isSchema(h),"Alteration adjuster for",d,"failed to return a schema object"));return h=h.$_modify({each:d=>d.tailor(u),ref:!1}),h.$_temp.ruleset=!1,h.$_mutateRebuild()}tracer(){return m.location?m.location(this):this}validate(u,h){return g.entry(u,this,h)}validateAsync(u,h){return g.entryAsync(u,this,h)}$_addRule(u){typeof u=="string"&&(u={name:u}),l(u&&typeof u=="object","Invalid options"),l(u.name&&typeof u.name=="string","Invalid rule name");for(const R in u)l(R[0]!=="_","Cannot set private rule properties");const h=Object.assign({},u);h._resolve=[],h.method=h.method||h.name;const d=this._definition.rules[h.method],w=h.args;l(d,"Unknown rule",h.method);const S=this.clone();if(w){l(Object.keys(w).length===1||Object.keys(w).length===this._definition.rules[h.name].args.length,"Invalid rule definition for",this.type,h.name);for(const R in w){let E=w[R];if(d.argsByName){const I=d.argsByName.get(R);if(I.ref&&n.isResolvable(E))h._resolve.push(R),S.$_mutateRegister(E);else if(I.normalize&&(E=I.normalize(E),w[R]=E),I.assert){const D=n.validateArg(E,R,I);l(!D,D,"or reference")}}E!==void 0?w[R]=E:delete w[R]}}return d.multi||(S._ruleRemove(h.name,{clone:!1}),S._singleRules.set(h.name,h)),S.$_temp.ruleset===!1&&(S.$_temp.ruleset=null),d.priority?S._rules.unshift(h):S._rules.push(h),S}$_compile(u,h){return i.schema(this.$_root,u,h)}$_createError(u,h,d,w,S){let R=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{};const E=R.flags!==!1?this._flags:{},I=R.messages?r.merge(this._definition.messages,R.messages):this._definition.messages;return new s.Report(u,h,d,E,I,w,S)}$_getFlag(u){return this._flags[u]}$_getRule(u){return this._singleRules.get(u)}$_mapLabels(u){return u=Array.isArray(u)?u:u.split("."),this._ids.labels(u)}$_match(u,h,d,w){(d=Object.assign({},d)).abortEarly=!0,d._externals=!1,h.snapshot();const S=!g.validate(u,this,h,d,w).errors;return h.restore(),S}$_modify(u){return n.assertOptions(u,["each","once","ref","schema"]),a.schema(this,u)||this}$_mutateRebuild(){return l(!this._inRuleset(),"Cannot add this rule inside a ruleset"),this._refs.reset(),this._ids.reset(),this.$_modify({each:(u,h)=>{let{source:d,name:w,path:S,key:R}=h;const E=this._definition[d][w]&&this._definition[d][w].register;E!==!1&&this.$_mutateRegister(u,{family:E,key:R})}}),this._definition.rebuild&&this._definition.rebuild(this),this.$_temp.ruleset=!1,this}$_mutateRegister(u){let{family:h,key:d}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this._refs.register(u,h),this._ids.register(u,{key:d})}$_property(u){return this._definition.properties[u]}$_reach(u){return this._ids.reach(u)}$_rootReferences(){return this._refs.roots()}$_setFlag(u,h){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};l(u[0]==="_"||!this._inRuleset(),"Cannot set flag inside a ruleset");const w=this._definition.flags[u]||{};if(y(h,w.default)&&(h=void 0),y(h,this._flags[u]))return this;const S=d.clone!==!1?this.clone():this;return h!==void 0?(S._flags[u]=h,S.$_mutateRegister(h)):delete S._flags[u],u[0]!=="_"&&(S.$_temp.ruleset=!1),S}$_parent(u){for(var h=arguments.length,d=new Array(h>1?h-1:0),w=1;w<h;w++)d[w-1]=arguments[w];return this[u][n.symbols.parent].call(this,...d)}$_validate(u,h,d){return g.validate(u,this,h,d)}_assign(u){u.type=this.type,u.$_root=this.$_root,u.$_temp=Object.assign({},this.$_temp),u.$_temp.whens={},u._ids=this._ids.clone(),u._preferences=this._preferences,u._valids=this._valids&&this._valids.clone(),u._invalids=this._invalids&&this._invalids.clone(),u._rules=this._rules.slice(),u._singleRules=p(this._singleRules,{shallow:!0}),u._refs=this._refs.clone(),u._flags=Object.assign({},this._flags),u._cache=null,u.$_terms={};for(const h in this.$_terms)u.$_terms[h]=this.$_terms[h]?this.$_terms[h].slice():null;u.$_super={};for(const h in this.$_super)u.$_super[h]=this._super[h].bind(u);return u}_bare(){const u=this.clone();u._reset();const h=u._definition.terms;for(const d in h){const w=h[d];u.$_terms[d]=w.init}return u.$_mutateRebuild()}_default(u,h){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return n.assertOptions(d,"literal"),l(h!==void 0,"Missing",u,"value"),l(typeof h=="function"||!d.literal,"Only function value supports literal option"),typeof h=="function"&&d.literal&&(h={[n.symbols.literal]:!0,literal:h}),this.$_setFlag(u,h)}_generate(u,h,d){if(!this.$_terms.whens)return{schema:this};const w=[],S=[];for(let I=0;I<this.$_terms.whens.length;++I){const D=this.$_terms.whens[I];if(D.concat){w.push(D.concat),S.push(`${I}.concat`);continue}const C=D.ref?D.ref.resolve(u,h,d):u,M=D.is?[D]:D.switch,L=S.length;for(let U=0;U<M.length;++U){const{is:T,then:N,otherwise:P}=M[U],q=`${I}${D.switch?"."+U:""}`;if(T.$_match(C,h.nest(T,`${q}.is`),d)){if(N){const W=h.localize([...h.path,`${q}.then`],h.ancestors,h.schemas),{schema:J,id:G}=N._generate(u,W,d);w.push(J),S.push(`${q}.then${G?`(${G})`:""}`);break}}else if(P){const W=h.localize([...h.path,`${q}.otherwise`],h.ancestors,h.schemas),{schema:J,id:G}=P._generate(u,W,d);w.push(J),S.push(`${q}.otherwise${G?`(${G})`:""}`);break}}if(D.break&&S.length>L)break}const R=S.join(", ");if(h.mainstay.tracer.debug(h,"rule","when",R),!R)return{schema:this};if(!h.mainstay.tracer.active&&this.$_temp.whens[R])return{schema:this.$_temp.whens[R],id:R};let E=this;this._definition.generate&&(E=this._definition.generate(this,u,h,d));for(const I of w)E=E.concat(I);return this.$_root._tracer&&this.$_root._tracer._combine(E,[this,...w]),this.$_temp.whens[R]=E,{schema:E,id:R}}_inner(u,h){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};l(!this._inRuleset(),`Cannot set ${u} inside a ruleset`);const w=this.clone();return w.$_terms[u]&&!d.override||(w.$_terms[u]=[]),d.single?w.$_terms[u].push(h):w.$_terms[u].push(...h),w.$_temp.ruleset=!1,w}_inRuleset(){return this.$_temp.ruleset!==null&&this.$_temp.ruleset!==!1}_ruleRemove(u){let h=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!this._singleRules.has(u))return this;const d=h.clone!==!1?this.clone():this;d._singleRules.delete(u);const w=[];for(let S=0;S<d._rules.length;++S){const R=d._rules[S];R.name!==u||R.keep?w.push(R):d._inRuleset()&&S<d.$_temp.ruleset&&--d.$_temp.ruleset}return d._rules=w,d}_values(u,h){n.verifyFlat(u,h.slice(1,-1));const d=this.clone(),w=u[0]===n.symbols.override;if(w&&(u=u.slice(1)),!d[h]&&u.length?d[h]=new _:w&&(d[h]=u.length?new _:null,d.$_mutateRebuild()),!d[h])return d;w&&d[h].override();for(const S of u){l(S!==void 0,"Cannot call allow/valid/invalid with undefined"),l(S!==n.symbols.override,"Override must be the first value");const R=h==="_invalids"?"_valids":"_invalids";d[R]&&(d[R].remove(S),d[R].length||(l(h==="_valids"||!d._flags.only,"Setting invalid value",S,"leaves schema rejecting all values due to previous valid rule"),d[R]=null)),d[h].add(S,d._refs)}return d}}};b.Base.prototype[n.symbols.any]={version:n.version,compile:i.compile,root:"$_root"},b.Base.prototype.isImmutable=!0,b.Base.prototype.deny=b.Base.prototype.invalid,b.Base.prototype.disallow=b.Base.prototype.invalid,b.Base.prototype.equal=b.Base.prototype.valid,b.Base.prototype.exist=b.Base.prototype.required,b.Base.prototype.not=b.Base.prototype.invalid,b.Base.prototype.options=b.Base.prototype.prefs,b.Base.prototype.preferences=b.Base.prototype.prefs,A.exports=new b.Base},8652:(A,$,v)=>{const l=v(375),p=v(8571),y=v(8160),f={max:1e3,supported:new Set(["undefined","boolean","number","string"])};$.provider={provision:t=>new f.Cache(t)},f.Cache=class{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};y.assertOptions(t,["max"]),l(t.max===void 0||t.max&&t.max>0&&isFinite(t.max),"Invalid max cache size"),this._max=t.max||f.max,this._map=new Map,this._list=new f.List}get length(){return this._map.size}set(t,n){if(t!==null&&!f.supported.has(typeof t))return;let i=this._map.get(t);if(i)return i.value=n,void this._list.first(i);i=this._list.unshift({key:t,value:n}),this._map.set(t,i),this._compact()}get(t){const n=this._map.get(t);if(n)return this._list.first(n),p(n.value)}_compact(){if(this._map.size>this._max){const t=this._list.pop();this._map.delete(t.key)}}},f.List=class{constructor(){this.tail=null,this.head=null}unshift(t){return t.next=null,t.prev=this.head,this.head&&(this.head.next=t),this.head=t,this.tail||(this.tail=t),t}first(t){t!==this.head&&(this._remove(t),this.unshift(t))}pop(){return this._remove(this.tail)}_remove(t){const{next:n,prev:i}=t;return n.prev=i,i&&(i.next=n),t===this.tail&&(this.tail=n),t.prev=null,t.next=null,t}}},8160:(A,$,v)=>{const l=v(375),p=v(7916),y=v(5934);let f,t;const n={isoDate:/^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/};$.version=y.version,$.defaults={abortEarly:!0,allowUnknown:!1,artifacts:!1,cache:!0,context:null,convert:!0,dateFormat:"iso",errors:{escapeHtml:!1,label:"path",language:null,render:!0,stack:!1,wrap:{label:'"',array:"[]"}},externals:!0,messages:{},nonEnumerables:!1,noDefaults:!1,presence:"optional",skipFunctions:!1,stripUnknown:!1,warnings:!1},$.symbols={any:Symbol.for("@hapi/joi/schema"),arraySingle:Symbol("arraySingle"),deepDefault:Symbol("deepDefault"),errors:Symbol("errors"),literal:Symbol("literal"),override:Symbol("override"),parent:Symbol("parent"),prefs:Symbol("prefs"),ref:Symbol("ref"),template:Symbol("template"),values:Symbol("values")},$.assertOptions=function(i,s){let e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"Options";l(i&&typeof i=="object"&&!Array.isArray(i),"Options must be of type object");const o=Object.keys(i).filter(r=>!s.includes(r));l(o.length===0,`${e} contain unknown keys: ${o}`)},$.checkPreferences=function(i){t=t||v(3378);const s=t.preferences.validate(i);if(s.error)throw new p([s.error.details[0].message])},$.compare=function(i,s,e){switch(e){case"=":return i===s;case">":return i>s;case"<":return i<s;case">=":return i>=s;case"<=":return i<=s}},$.default=function(i,s){return i===void 0?s:i},$.isIsoDate=function(i){return n.isoDate.test(i)},$.isNumber=function(i){return typeof i=="number"&&!isNaN(i)},$.isResolvable=function(i){return!!i&&(i[$.symbols.ref]||i[$.symbols.template])},$.isSchema=function(i){let s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const e=i&&i[$.symbols.any];return!!e&&(l(s.legacy||e.version===$.version,"Cannot mix different versions of joi schemas"),!0)},$.isValues=function(i){return i[$.symbols.values]},$.limit=function(i){return Number.isSafeInteger(i)&&i>=0},$.preferences=function(i,s){f=f||v(6914),i=i||{},s=s||{};const e=Object.assign({},i,s);return s.errors&&i.errors&&(e.errors=Object.assign({},i.errors,s.errors),e.errors.wrap=Object.assign({},i.errors.wrap,s.errors.wrap)),s.messages&&(e.messages=f.compile(s.messages,i.messages)),delete e[$.symbols.prefs],e},$.tryWithPath=function(i,s){let e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};try{return i()}catch(o){throw o.path!==void 0?o.path=s+"."+o.path:o.path=s,e.append&&(o.message=`${o.message} (${o.path})`),o}},$.validateArg=function(i,s,e){let{assert:o,message:r}=e;if($.isSchema(o)){const a=o.validate(i);return a.error?a.error.message:void 0}if(!o(i))return s?`${s} ${r}`:r},$.verifyFlat=function(i,s){for(const e of i)l(!Array.isArray(e),"Method no longer accepts array arguments:",s)}},3292:(A,$,v)=>{const l=v(375),p=v(8160),y=v(6133),f={};$.schema=function(t,n){let i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};p.assertOptions(i,["appendPath","override"]);try{return f.schema(t,n,i)}catch(s){throw i.appendPath&&s.path!==void 0&&(s.message=`${s.message} (${s.path})`),s}},f.schema=function(t,n,i){l(n!==void 0,"Invalid undefined schema"),Array.isArray(n)&&(l(n.length,"Invalid empty array schema"),n.length===1&&(n=n[0]));const s=function(e){for(var o=arguments.length,r=new Array(o>1?o-1:0),a=1;a<o;a++)r[a-1]=arguments[a];return i.override!==!1?e.valid(t.override,...r):e.valid(...r)};if(f.simple(n))return s(t,n);if(typeof n=="function")return t.custom(n);if(l(typeof n=="object","Invalid schema content:",typeof n),p.isResolvable(n))return s(t,n);if(p.isSchema(n))return n;if(Array.isArray(n)){for(const e of n)if(!f.simple(e))return t.alternatives().try(...n);return s(t,...n)}return n instanceof RegExp?t.string().regex(n):n instanceof Date?s(t.date(),n):(l(Object.getPrototypeOf(n)===Object.getPrototypeOf({}),"Schema can only contain plain objects"),t.object().keys(n))},$.ref=function(t,n){return y.isRef(t)?t:y.create(t,n)},$.compile=function(t,n){let i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};p.assertOptions(i,["legacy"]);const s=n&&n[p.symbols.any];if(s)return l(i.legacy||s.version===p.version,"Cannot mix different versions of joi schemas:",s.version,p.version),n;if(typeof n!="object"||!i.legacy)return $.schema(t,n,{appendPath:!0});const e=f.walk(n);return e?e.compile(e.root,n):$.schema(t,n,{appendPath:!0})},f.walk=function(t){if(typeof t!="object")return null;if(Array.isArray(t)){for(const i of t){const s=f.walk(i);if(s)return s}return null}const n=t[p.symbols.any];if(n)return{root:t[n.root],compile:n.compile};l(Object.getPrototypeOf(t)===Object.getPrototypeOf({}),"Schema can only contain plain objects");for(const i in t){const s=f.walk(t[i]);if(s)return s}return null},f.simple=function(t){return t===null||["boolean","string","number"].includes(typeof t)},$.when=function(t,n,i){if(i===void 0&&(l(n&&typeof n=="object","Missing options"),i=n,n=y.create(".")),Array.isArray(i)&&(i={switch:i}),p.assertOptions(i,["is","not","then","otherwise","switch","break"]),p.isSchema(n))return l(i.is===void 0,'"is" can not be used with a schema condition'),l(i.not===void 0,'"not" can not be used with a schema condition'),l(i.switch===void 0,'"switch" can not be used with a schema condition'),f.condition(t,{is:n,then:i.then,otherwise:i.otherwise,break:i.break});if(l(y.isRef(n)||typeof n=="string","Invalid condition:",n),l(i.not===void 0||i.is===void 0,'Cannot combine "is" with "not"'),i.switch===void 0){let e=i;i.not!==void 0&&(e={is:i.not,then:i.otherwise,otherwise:i.then,break:i.break});let o=e.is!==void 0?t.$_compile(e.is):t.$_root.invalid(null,!1,0,"").required();return l(e.then!==void 0||e.otherwise!==void 0,'options must have at least one of "then", "otherwise", or "switch"'),l(e.break===void 0||e.then===void 0||e.otherwise===void 0,"Cannot specify then, otherwise, and break all together"),i.is===void 0||y.isRef(i.is)||p.isSchema(i.is)||(o=o.required()),f.condition(t,{ref:$.ref(n),is:o,then:e.then,otherwise:e.otherwise,break:e.break})}l(Array.isArray(i.switch),'"switch" must be an array'),l(i.is===void 0,'Cannot combine "switch" with "is"'),l(i.not===void 0,'Cannot combine "switch" with "not"'),l(i.then===void 0,'Cannot combine "switch" with "then"');const s={ref:$.ref(n),switch:[],break:i.break};for(let e=0;e<i.switch.length;++e){const o=i.switch[e],r=e===i.switch.length-1;p.assertOptions(o,r?["is","then","otherwise"]:["is","then"]),l(o.is!==void 0,'Switch statement missing "is"'),l(o.then!==void 0,'Switch statement missing "then"');const a={is:t.$_compile(o.is),then:t.$_compile(o.then)};if(y.isRef(o.is)||p.isSchema(o.is)||(a.is=a.is.required()),r){l(i.otherwise===void 0||o.otherwise===void 0,'Cannot specify "otherwise" inside and outside a "switch"');const c=i.otherwise!==void 0?i.otherwise:o.otherwise;c!==void 0&&(l(s.break===void 0,"Cannot specify both otherwise and break"),a.otherwise=t.$_compile(c))}s.switch.push(a)}return s},f.condition=function(t,n){for(const i of["then","otherwise"])n[i]===void 0?delete n[i]:n[i]=t.$_compile(n[i]);return n}},6354:(A,$,v)=>{const l=v(5688),p=v(8160),y=v(3328);$.Report=class{constructor(f,t,n,i,s,e,o){if(this.code=f,this.flags=i,this.messages=s,this.path=e.path,this.prefs=o,this.state=e,this.value=t,this.message=null,this.template=null,this.local=n||{},this.local.label=$.label(this.flags,this.state,this.prefs,this.messages),this.value===void 0||this.local.hasOwnProperty("value")||(this.local.value=this.value),this.path.length){const r=this.path[this.path.length-1];typeof r!="object"&&(this.local.key=r)}}_setTemplate(f){if(this.template=f,!this.flags.label&&this.path.length===0){const t=this._template(this.template,"root");t&&(this.local.label=t)}}toString(){if(this.message)return this.message;const f=this.code;if(!this.prefs.errors.render)return this.code;const t=this._template(this.template)||this._template(this.prefs.messages)||this._template(this.messages);return t===void 0?`Error code "${f}" is not defined, your custom type is missing the correct messages definition`:(this.message=t.render(this.value,this.state,this.prefs,this.local,{errors:this.prefs.errors,messages:[this.prefs.messages,this.messages]}),this.prefs.errors.label||(this.message=this.message.replace(/^"" /,"").trim()),this.message)}_template(f,t){return $.template(this.value,f,t||this.code,this.state,this.prefs)}},$.path=function(f){let t="";for(const n of f)typeof n!="object"&&(typeof n=="string"?(t&&(t+="."),t+=n):t+=`[${n}]`);return t},$.template=function(f,t,n,i,s){if(!t)return;if(y.isTemplate(t))return n!=="root"?t:null;let e=s.errors.language;if(p.isResolvable(e)&&(e=e.resolve(f,i,s)),e&&t[e]){if(t[e][n]!==void 0)return t[e][n];if(t[e]["*"]!==void 0)return t[e]["*"]}return t[n]?t[n]:t["*"]},$.label=function(f,t,n,i){if(f.label)return f.label;if(!n.errors.label)return"";let s=t.path;return n.errors.label==="key"&&t.path.length>1&&(s=t.path.slice(-1)),$.path(s)||$.template(null,n.messages,"root",t,n)||i&&$.template(null,i,"root",t,n)||"value"},$.process=function(f,t,n){if(!f)return null;const{override:i,message:s,details:e}=$.details(f);if(i)return i;if(n.errors.stack)return new $.ValidationError(s,e,t);const o=Error.stackTraceLimit;Error.stackTraceLimit=0;const r=new $.ValidationError(s,e,t);return Error.stackTraceLimit=o,r},$.details=function(f){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},n=[];const i=[];for(const s of f){if(s instanceof Error){if(t.override!==!1)return{override:s};const o=s.toString();n.push(o),i.push({message:o,type:"override",context:{error:s}});continue}const e=s.toString();n.push(e),i.push({message:e,path:s.path.filter(o=>typeof o!="object"),type:s.code,context:s.local})}return n.length>1&&(n=[...new Set(n)]),{message:n.join(". "),details:i}},$.ValidationError=class extends Error{constructor(f,t,n){super(f),this._original=n,this.details=t}static isError(f){return f instanceof $.ValidationError}},$.ValidationError.prototype.isJoi=!0,$.ValidationError.prototype.name="ValidationError",$.ValidationError.prototype.annotate=l.error},8901:(A,$,v)=>{const l=v(375),p=v(8571),y=v(8160),f=v(6914),t={};$.type=function(n,i){const s=Object.getPrototypeOf(n),e=p(s),o=n._assign(Object.create(e)),r=Object.assign({},i);delete r.base,e._definition=r;const a=s._definition||{};r.messages=f.merge(a.messages,r.messages),r.properties=Object.assign({},a.properties,r.properties),o.type=r.type,r.flags=Object.assign({},a.flags,r.flags);const c=Object.assign({},a.terms);if(r.terms)for(const b in r.terms){const u=r.terms[b];l(o.$_terms[b]===void 0,"Invalid term override for",r.type,b),o.$_terms[b]=u.init,c[b]=u}r.terms=c,r.args||(r.args=a.args),r.prepare=t.prepare(r.prepare,a.prepare),r.coerce&&(typeof r.coerce=="function"&&(r.coerce={method:r.coerce}),r.coerce.from&&!Array.isArray(r.coerce.from)&&(r.coerce={method:r.coerce.method,from:[].concat(r.coerce.from)})),r.coerce=t.coerce(r.coerce,a.coerce),r.validate=t.validate(r.validate,a.validate);const m=Object.assign({},a.rules);if(r.rules)for(const b in r.rules){const u=r.rules[b];l(typeof u=="object","Invalid rule definition for",r.type,b);let h=u.method;if(h===void 0&&(h=function(){return this.$_addRule(b)}),h&&(l(!e[b],"Rule conflict in",r.type,b),e[b]=h),l(!m[b],"Rule conflict in",r.type,b),m[b]=u,u.alias){const d=[].concat(u.alias);for(const w of d)e[w]=u.method}u.args&&(u.argsByName=new Map,u.args=u.args.map(d=>(typeof d=="string"&&(d={name:d}),l(!u.argsByName.has(d.name),"Duplicated argument name",d.name),y.isSchema(d.assert)&&(d.assert=d.assert.strict().label(d.name)),u.argsByName.set(d.name,d),d)))}r.rules=m;const g=Object.assign({},a.modifiers);if(r.modifiers)for(const b in r.modifiers){l(!e[b],"Rule conflict in",r.type,b);const u=r.modifiers[b];l(typeof u=="function","Invalid modifier definition for",r.type,b);const h=function(d){return this.rule({[b]:d})};e[b]=h,g[b]=u}if(r.modifiers=g,r.overrides){e._super=s,o.$_super={};for(const b in r.overrides)l(s[b],"Cannot override missing",b),r.overrides[b][y.symbols.parent]=s[b],o.$_super[b]=s[b].bind(o);Object.assign(e,r.overrides)}r.cast=Object.assign({},a.cast,r.cast);const _=Object.assign({},a.manifest,r.manifest);return _.build=t.build(r.manifest&&r.manifest.build,a.manifest&&a.manifest.build),r.manifest=_,r.rebuild=t.rebuild(r.rebuild,a.rebuild),o},t.build=function(n,i){return n&&i?function(s,e){return i(n(s,e),e)}:n||i},t.coerce=function(n,i){return n&&i?{from:n.from&&i.from?[...new Set([...n.from,...i.from])]:null,method(s,e){let o;if((!i.from||i.from.includes(typeof s))&&(o=i.method(s,e),o)){if(o.errors||o.value===void 0)return o;s=o.value}if(!n.from||n.from.includes(typeof s)){const r=n.method(s,e);if(r)return r}return o}}:n||i},t.prepare=function(n,i){return n&&i?function(s,e){const o=n(s,e);if(o){if(o.errors||o.value===void 0)return o;s=o.value}return i(s,e)||o}:n||i},t.rebuild=function(n,i){return n&&i?function(s){i(s),n(s)}:n||i},t.validate=function(n,i){return n&&i?function(s,e){const o=i(s,e);if(o){if(o.errors&&(!Array.isArray(o.errors)||o.errors.length))return o;s=o.value}return n(s,e)||o}:n||i}},5107:(A,$,v)=>{const l=v(375),p=v(8571),y=v(8652),f=v(8160),t=v(3292),n=v(6354),i=v(8901),s=v(9708),e=v(6133),o=v(3328),r=v(1152);let a;const c={types:{alternatives:v(4946),any:v(8068),array:v(546),boolean:v(4937),date:v(7500),function:v(390),link:v(8785),number:v(3832),object:v(8966),string:v(7417),symbol:v(8826)},aliases:{alt:"alternatives",bool:"boolean",func:"function"},root:function(){const m={_types:new Set(Object.keys(c.types))};for(const g of m._types)m[g]=function(){for(var _=arguments.length,b=new Array(_),u=0;u<_;u++)b[u]=arguments[u];return l(!b.length||["alternatives","link","object"].includes(g),"The",g,"type does not allow arguments"),c.generate(this,c.types[g],b)};for(const g of["allow","custom","disallow","equal","exist","forbidden","invalid","not","only","optional","options","prefs","preferences","required","strip","valid","when"])m[g]=function(){return this.any()[g](...arguments)};Object.assign(m,c.methods);for(const g in c.aliases){const _=c.aliases[g];m[g]=m[_]}return m.x=m.expression,r.setup&&r.setup(m),m}};c.methods={ValidationError:n.ValidationError,version:f.version,cache:y.provider,assert(m,g){for(var _=arguments.length,b=new Array(_>2?_-2:0),u=2;u<_;u++)b[u-2]=arguments[u];c.assert(m,g,!0,b)},attempt(m,g){for(var _=arguments.length,b=new Array(_>2?_-2:0),u=2;u<_;u++)b[u-2]=arguments[u];return c.assert(m,g,!1,b)},build(m){return l(typeof s.build=="function","Manifest functionality disabled"),s.build(this,m)},checkPreferences(m){f.checkPreferences(m)},compile(m,g){return t.compile(this,m,g)},defaults(m){l(typeof m=="function","modifier must be a function");const g=Object.assign({},this);for(const _ of g._types){const b=m(g[_]());l(f.isSchema(b),"modifier must return a valid schema object"),g[_]=function(){for(var u=arguments.length,h=new Array(u),d=0;d<u;d++)h[d]=arguments[d];return c.generate(this,b,h)}}return g},expression(){for(var m=arguments.length,g=new Array(m),_=0;_<m;_++)g[_]=arguments[_];return new o(...g)},extend(){for(var m=arguments.length,g=new Array(m),_=0;_<m;_++)g[_]=arguments[_];f.verifyFlat(g,"extend"),a=a||v(3378),l(g.length,"You need to provide at least one extension"),this.assert(g,a.extensions);const b=Object.assign({},this);b._types=new Set(b._types);for(let u of g){typeof u=="function"&&(u=u(b)),this.assert(u,a.extension);const h=c.expandExtension(u,b);for(const d of h){l(b[d.type]===void 0||b._types.has(d.type),"Cannot override name",d.type);const w=d.base||this.any(),S=i.type(w,d);b._types.add(d.type),b[d.type]=function(){for(var R=arguments.length,E=new Array(R),I=0;I<R;I++)E[I]=arguments[I];return c.generate(this,S,E)}}}return b},isError:n.ValidationError.isError,isExpression:o.isTemplate,isRef:e.isRef,isSchema:f.isSchema,in(){return e.in(...arguments)},override:f.symbols.override,ref(){return e.create(...arguments)},types(){const m={};for(const g of this._types)m[g]=this[g]();for(const g in c.aliases)m[g]=this[g]();return m}},c.assert=function(m,g,_,b){const u=b[0]instanceof Error||typeof b[0]=="string"?b[0]:null,h=u!==null?b[1]:b[0],d=g.validate(m,f.preferences({errors:{stack:!0}},h||{}));let w=d.error;if(!w)return d.value;if(u instanceof Error)throw u;const S=_&&typeof w.annotate=="function"?w.annotate():w.message;throw w instanceof n.ValidationError==0&&(w=p(w)),w.message=u?`${u} ${S}`:S,w},c.generate=function(m,g,_){return l(m,"Must be invoked on a Joi instance."),g.$_root=m,g._definition.args&&_.length?g._definition.args(g,..._):g},c.expandExtension=function(m,g){if(typeof m.type=="string")return[m];const _=[];for(const b of g._types)if(m.type.test(b)){const u=Object.assign({},m);u.type=b,u.base=g[b](),_.push(u)}return _},A.exports=c.root()},6914:(A,$,v)=>{const l=v(375),p=v(8571),y=v(3328);$.compile=function(f,t){if(typeof f=="string")return l(!t,"Cannot set single message string"),new y(f);if(y.isTemplate(f))return l(!t,"Cannot set single message template"),f;l(typeof f=="object"&&!Array.isArray(f),"Invalid message options"),t=t?p(t):{};for(let n in f){const i=f[n];if(n==="root"||y.isTemplate(i)){t[n]=i;continue}if(typeof i=="string"){t[n]=new y(i);continue}l(typeof i=="object"&&!Array.isArray(i),"Invalid message for",n);const s=n;for(n in t[s]=t[s]||{},i){const e=i[n];n==="root"||y.isTemplate(e)?t[s][n]=e:(l(typeof e=="string","Invalid message for",n,"in",s),t[s][n]=new y(e))}}return t},$.decompile=function(f){const t={};for(let n in f){const i=f[n];if(n==="root"){t.root=i;continue}if(y.isTemplate(i)){t[n]=i.describe({compact:!0});continue}const s=n;for(n in t[s]={},i){const e=i[n];n!=="root"?t[s][n]=e.describe({compact:!0}):t[s].root=e}}return t},$.merge=function(f,t){if(!f)return $.compile(t);if(!t)return f;if(typeof t=="string")return new y(t);if(y.isTemplate(t))return t;const n=p(f);for(let i in t){const s=t[i];if(i==="root"||y.isTemplate(s)){n[i]=s;continue}if(typeof s=="string"){n[i]=new y(s);continue}l(typeof s=="object"&&!Array.isArray(s),"Invalid message for",i);const e=i;for(i in n[e]=n[e]||{},s){const o=s[i];i==="root"||y.isTemplate(o)?n[e][i]=o:(l(typeof o=="string","Invalid message for",i,"in",e),n[e][i]=new y(o))}}return n}},2294:(A,$,v)=>{const l=v(375),p=v(8160),y=v(6133),f={};$.Ids=f.Ids=class{constructor(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}clone(){const t=new f.Ids;return t._byId=new Map(this._byId),t._byKey=new Map(this._byKey),t._schemaChain=this._schemaChain,t}concat(t){t._schemaChain&&(this._schemaChain=!0);for(const[n,i]of t._byId.entries())l(!this._byKey.has(n),"Schema id conflicts with existing key:",n),this._byId.set(n,i);for(const[n,i]of t._byKey.entries())l(!this._byId.has(n),"Schema key conflicts with existing id:",n),this._byKey.set(n,i)}fork(t,n,i){const s=this._collect(t);s.push({schema:i});const e=s.shift();let o={id:e.id,schema:n(e.schema)};l(p.isSchema(o.schema),"adjuster function failed to return a joi schema type");for(const r of s)o={id:r.id,schema:f.fork(r.schema,o.id,o.schema)};return o.schema}labels(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];const i=t[0],s=this._get(i);if(!s)return[...n,...t].join(".");const e=t.slice(1);return n=[...n,s.schema._flags.label||i],e.length?s.schema._ids.labels(e,n):n.join(".")}reach(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];const i=t[0],s=this._get(i);l(s,"Schema does not contain path",[...n,...t].join("."));const e=t.slice(1);return e.length?s.schema._ids.reach(e,[...n,i]):s.schema}register(t){let{key:n}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!t||!p.isSchema(t))return;(t.$_property("schemaChain")||t._ids._schemaChain)&&(this._schemaChain=!0);const i=t._flags.id;if(i){const s=this._byId.get(i);l(!s||s.schema===t,"Cannot add different schemas with the same id:",i),l(!this._byKey.has(i),"Schema id conflicts with existing key:",i),this._byId.set(i,{schema:t,id:i})}n&&(l(!this._byKey.has(n),"Schema already contains key:",n),l(!this._byId.has(n),"Schema key conflicts with existing id:",n),this._byKey.set(n,{schema:t,id:n}))}reset(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}_collect(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[],i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:[];const s=t[0],e=this._get(s);l(e,"Schema does not contain path",[...n,...t].join(".")),i=[e,...i];const o=t.slice(1);return o.length?e.schema._ids._collect(o,[...n,s],i):i}_get(t){return this._byId.get(t)||this._byKey.get(t)}},f.fork=function(t,n,i){const s=$.schema(t,{each:(e,o)=>{let{key:r}=o;if(n===(e._flags.id||r))return i},ref:!1});return s?s.$_mutateRebuild():t},$.schema=function(t,n){let i;for(const s in t._flags){if(s[0]==="_")continue;const e=f.scan(t._flags[s],{source:"flags",name:s},n);e!==void 0&&(i=i||t.clone(),i._flags[s]=e)}for(let s=0;s<t._rules.length;++s){const e=t._rules[s],o=f.scan(e.args,{source:"rules",name:e.name},n);if(o!==void 0){i=i||t.clone();const r=Object.assign({},e);r.args=o,i._rules[s]=r,i._singleRules.get(e.name)===e&&i._singleRules.set(e.name,r)}}for(const s in t.$_terms){if(s[0]==="_")continue;const e=f.scan(t.$_terms[s],{source:"terms",name:s},n);e!==void 0&&(i=i||t.clone(),i.$_terms[s]=e)}return i},f.scan=function(t,n,i,s,e){const o=s||[];if(t===null||typeof t!="object")return;let r;if(Array.isArray(t)){for(let a=0;a<t.length;++a){const c=n.source==="terms"&&n.name==="keys"&&t[a].key,m=f.scan(t[a],n,i,[a,...o],c);m!==void 0&&(r=r||t.slice(),r[a]=m)}return r}if(i.schema!==!1&&p.isSchema(t)||i.ref!==!1&&y.isRef(t)){const a=i.each(t,{...n,path:o,key:e});return a===t?void 0:a}for(const a in t){if(a[0]==="_")continue;const c=f.scan(t[a],n,i,[a,...o],e);c!==void 0&&(r=r||Object.assign({},t),r[a]=c)}return r}},6133:(A,$,v)=>{const l=v(375),p=v(8571),y=v(9621),f=v(8160);let t;const n={symbol:Symbol("ref"),defaults:{adjust:null,in:!1,iterables:null,map:null,separator:".",type:"value"}};$.create=function(i){let s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};l(typeof i=="string","Invalid reference key:",i),f.assertOptions(s,["adjust","ancestor","in","iterables","map","prefix","render","separator"]),l(!s.prefix||typeof s.prefix=="object","options.prefix must be of type object");const e=Object.assign({},n.defaults,s);delete e.prefix;const o=e.separator,r=n.context(i,o,s.prefix);if(e.type=r.type,i=r.key,e.type==="value")if(r.root&&(l(!o||i[0]!==o,"Cannot specify relative path with root prefix"),e.ancestor="root",i||(i=null)),o&&o===i)i=null,e.ancestor=0;else if(e.ancestor!==void 0)l(!o||!i||i[0]!==o,"Cannot combine prefix with ancestor option");else{const[a,c]=n.ancestor(i,o);c&&(i=i.slice(c))===""&&(i=null),e.ancestor=a}return e.path=o?i===null?[]:i.split(o):[i],new n.Ref(e)},$.in=function(i){let s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return $.create(i,{...s,in:!0})},$.isRef=function(i){return!!i&&!!i[f.symbols.ref]},n.Ref=class{constructor(i){l(typeof i=="object","Invalid reference construction"),f.assertOptions(i,["adjust","ancestor","in","iterables","map","path","render","separator","type","depth","key","root","display"]),l([!1,void 0].includes(i.separator)||typeof i.separator=="string"&&i.separator.length===1,"Invalid separator"),l(!i.adjust||typeof i.adjust=="function","options.adjust must be a function"),l(!i.map||Array.isArray(i.map),"options.map must be an array"),l(!i.map||!i.adjust,"Cannot set both map and adjust options"),Object.assign(this,n.defaults,i),l(this.type==="value"||this.ancestor===void 0,"Non-value references cannot reference ancestors"),Array.isArray(this.map)&&(this.map=new Map(this.map)),this.depth=this.path.length,this.key=this.path.length?this.path.join(this.separator):null,this.root=this.path[0],this.updateDisplay()}resolve(i,s,e,o){let r=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{};return l(!this.in||r.in,"Invalid in() reference usage"),this.type==="global"?this._resolve(e.context,s,r):this.type==="local"?this._resolve(o,s,r):this.ancestor?this.ancestor==="root"?this._resolve(s.ancestors[s.ancestors.length-1],s,r):(l(this.ancestor<=s.ancestors.length,"Invalid reference exceeds the schema root:",this.display),this._resolve(s.ancestors[this.ancestor-1],s,r)):this._resolve(i,s,r)}_resolve(i,s,e){let o;if(this.type==="value"&&s.mainstay.shadow&&e.shadow!==!1&&(o=s.mainstay.shadow.get(this.absolute(s))),o===void 0&&(o=y(i,this.path,{iterables:this.iterables,functions:!0})),this.adjust&&(o=this.adjust(o)),this.map){const r=this.map.get(o);r!==void 0&&(o=r)}return s.mainstay&&s.mainstay.tracer.resolve(s,this,o),o}toString(){return this.display}absolute(i){return[...i.path.slice(0,-this.ancestor),...this.path]}clone(){return new n.Ref(this)}describe(){const i={path:this.path};this.type!=="value"&&(i.type=this.type),this.separator!=="."&&(i.separator=this.separator),this.type==="value"&&this.ancestor!==1&&(i.ancestor=this.ancestor),this.map&&(i.map=[...this.map]);for(const s of["adjust","iterables","render"])this[s]!==null&&this[s]!==void 0&&(i[s]=this[s]);return this.in!==!1&&(i.in=!0),{ref:i}}updateDisplay(){const i=this.key!==null?this.key:"";if(this.type!=="value")return void(this.display=`ref:${this.type}:${i}`);if(!this.separator)return void(this.display=`ref:${i}`);if(!this.ancestor)return void(this.display=`ref:${this.separator}${i}`);if(this.ancestor==="root")return void(this.display=`ref:root:${i}`);if(this.ancestor===1)return void(this.display=`ref:${i||".."}`);const s=new Array(this.ancestor+1).fill(this.separator).join("");this.display=`ref:${s}${i||""}`}},n.Ref.prototype[f.symbols.ref]=!0,$.build=function(i){return(i=Object.assign({},n.defaults,i)).type==="value"&&i.ancestor===void 0&&(i.ancestor=1),new n.Ref(i)},n.context=function(i,s){let e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(i=i.trim(),e){const o=e.global===void 0?"$":e.global;if(o!==s&&i.startsWith(o))return{key:i.slice(o.length),type:"global"};const r=e.local===void 0?"#":e.local;if(r!==s&&i.startsWith(r))return{key:i.slice(r.length),type:"local"};const a=e.root===void 0?"/":e.root;if(a!==s&&i.startsWith(a))return{key:i.slice(a.length),type:"value",root:!0}}return{key:i,type:"value"}},n.ancestor=function(i,s){if(!s)return[1,0];if(i[0]!==s)return[1,0];if(i[1]!==s)return[0,1];let e=2;for(;i[e]===s;)++e;return[e-1,e]},$.toSibling=0,$.toParent=1,$.Manager=class{constructor(){this.refs=[]}register(i,s){if(i)if(s=s===void 0?$.toParent:s,Array.isArray(i))for(const e of i)this.register(e,s);else if(f.isSchema(i))for(const e of i._refs.refs)e.ancestor-s>=0&&this.refs.push({ancestor:e.ancestor-s,root:e.root});else $.isRef(i)&&i.type==="value"&&i.ancestor-s>=0&&this.refs.push({ancestor:i.ancestor-s,root:i.root}),t=t||v(3328),t.isTemplate(i)&&this.register(i.refs(),s)}get length(){return this.refs.length}clone(){const i=new $.Manager;return i.refs=p(this.refs),i}reset(){this.refs=[]}roots(){return this.refs.filter(i=>!i.ancestor).map(i=>i.root)}}},3378:(A,$,v)=>{const l=v(5107),p={};p.wrap=l.string().min(1).max(2).allow(!1),$.preferences=l.object({allowUnknown:l.boolean(),abortEarly:l.boolean(),artifacts:l.boolean(),cache:l.boolean(),context:l.object(),convert:l.boolean(),dateFormat:l.valid("date","iso","string","time","utc"),debug:l.boolean(),errors:{escapeHtml:l.boolean(),label:l.valid("path","key",!1),language:[l.string(),l.object().ref()],render:l.boolean(),stack:l.boolean(),wrap:{label:p.wrap,array:p.wrap,string:p.wrap}},externals:l.boolean(),messages:l.object(),noDefaults:l.boolean(),nonEnumerables:l.boolean(),presence:l.valid("required","optional","forbidden"),skipFunctions:l.boolean(),stripUnknown:l.object({arrays:l.boolean(),objects:l.boolean()}).or("arrays","objects").allow(!0,!1),warnings:l.boolean()}).strict(),p.nameRx=/^[a-zA-Z0-9]\w*$/,p.rule=l.object({alias:l.array().items(l.string().pattern(p.nameRx)).single(),args:l.array().items(l.string(),l.object({name:l.string().pattern(p.nameRx).required(),ref:l.boolean(),assert:l.alternatives([l.function(),l.object().schema()]).conditional("ref",{is:!0,then:l.required()}),normalize:l.function(),message:l.string().when("assert",{is:l.function(),then:l.required()})})),convert:l.boolean(),manifest:l.boolean(),method:l.function().allow(!1),multi:l.boolean(),validate:l.function()}),$.extension=l.object({type:l.alternatives([l.string(),l.object().regex()]).required(),args:l.function(),cast:l.object().pattern(p.nameRx,l.object({from:l.function().maxArity(1).required(),to:l.function().minArity(1).maxArity(2).required()})),base:l.object().schema().when("type",{is:l.object().regex(),then:l.forbidden()}),coerce:[l.function().maxArity(3),l.object({method:l.function().maxArity(3).required(),from:l.array().items(l.string()).single()})],flags:l.object().pattern(p.nameRx,l.object({setter:l.string(),default:l.any()})),manifest:{build:l.function().arity(2)},messages:[l.object(),l.string()],modifiers:l.object().pattern(p.nameRx,l.function().minArity(1).maxArity(2)),overrides:l.object().pattern(p.nameRx,l.function()),prepare:l.function().maxArity(3),rebuild:l.function().arity(1),rules:l.object().pattern(p.nameRx,p.rule),terms:l.object().pattern(p.nameRx,l.object({init:l.array().allow(null).required(),manifest:l.object().pattern(/.+/,[l.valid("schema","single"),l.object({mapped:l.object({from:l.string().required(),to:l.string().required()}).required()})])})),validate:l.function().maxArity(3)}).strict(),$.extensions=l.array().items(l.object(),l.function().arity(1)).strict(),p.desc={buffer:l.object({buffer:l.string()}),func:l.object({function:l.function().required(),options:{literal:!0}}),override:l.object({override:!0}),ref:l.object({ref:l.object({type:l.valid("value","global","local"),path:l.array().required(),separator:l.string().length(1).allow(!1),ancestor:l.number().min(0).integer().allow("root"),map:l.array().items(l.array().length(2)).min(1),adjust:l.function(),iterables:l.boolean(),in:l.boolean(),render:l.boolean()}).required()}),regex:l.object({regex:l.string().min(3)}),special:l.object({special:l.valid("deep").required()}),template:l.object({template:l.string().required(),options:l.object()}),value:l.object({value:l.alternatives([l.object(),l.array()]).required()})},p.desc.entity=l.alternatives([l.array().items(l.link("...")),l.boolean(),l.function(),l.number(),l.string(),p.desc.buffer,p.desc.func,p.desc.ref,p.desc.regex,p.desc.special,p.desc.template,p.desc.value,l.link("/")]),p.desc.values=l.array().items(null,l.boolean(),l.function(),l.number().allow(1/0,-1/0),l.string().allow(""),l.symbol(),p.desc.buffer,p.desc.func,p.desc.override,p.desc.ref,p.desc.regex,p.desc.template,p.desc.value),p.desc.messages=l.object().pattern(/.+/,[l.string(),p.desc.template,l.object().pattern(/.+/,[l.string(),p.desc.template])]),$.description=l.object({type:l.string().required(),flags:l.object({cast:l.string(),default:l.any(),description:l.string(),empty:l.link("/"),failover:p.desc.entity,id:l.string(),label:l.string(),only:!0,presence:["optional","required","forbidden"],result:["raw","strip"],strip:l.boolean(),unit:l.string()}).unknown(),preferences:{allowUnknown:l.boolean(),abortEarly:l.boolean(),artifacts:l.boolean(),cache:l.boolean(),convert:l.boolean(),dateFormat:["date","iso","string","time","utc"],errors:{escapeHtml:l.boolean(),label:["path","key"],language:[l.string(),p.desc.ref],wrap:{label:p.wrap,array:p.wrap}},externals:l.boolean(),messages:p.desc.messages,noDefaults:l.boolean(),nonEnumerables:l.boolean(),presence:["required","optional","forbidden"],skipFunctions:l.boolean(),stripUnknown:l.object({arrays:l.boolean(),objects:l.boolean()}).or("arrays","objects").allow(!0,!1),warnings:l.boolean()},allow:p.desc.values,invalid:p.desc.values,rules:l.array().min(1).items({name:l.string().required(),args:l.object().min(1),keep:l.boolean(),message:[l.string(),p.desc.messages],warn:l.boolean()}),keys:l.object().pattern(/.*/,l.link("/")),link:p.desc.ref}).pattern(/^[a-z]\w*$/,l.any())},493:(A,$,v)=>{const l=v(8571),p=v(9621),y=v(8160),f={value:Symbol("value")};A.exports=f.State=class{constructor(t,n,i){this.path=t,this.ancestors=n,this.mainstay=i.mainstay,this.schemas=i.schemas,this.debug=null}localize(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null,i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:null;const s=new f.State(t,n,this);return i&&s.schemas&&(s.schemas=[f.schemas(i),...s.schemas]),s}nest(t,n){const i=new f.State(this.path,this.ancestors,this);return i.schemas=i.schemas&&[f.schemas(t),...i.schemas],i.debug=n,i}shadow(t,n){this.mainstay.shadow=this.mainstay.shadow||new f.Shadow,this.mainstay.shadow.set(this.path,t,n)}snapshot(){this.mainstay.shadow&&(this._snapshot=l(this.mainstay.shadow.node(this.path))),this.mainstay.snapshot()}restore(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.restore()}},f.schemas=function(t){return y.isSchema(t)?{schema:t}:t},f.Shadow=class{constructor(){this._values=null}set(t,n,i){if(!t.length||i==="strip"&&typeof t[t.length-1]=="number")return;this._values=this._values||new Map;let s=this._values;for(let e=0;e<t.length;++e){const o=t[e];let r=s.get(o);r||(r=new Map,s.set(o,r)),s=r}s[f.value]=n}get(t){const n=this.node(t);if(n)return n[f.value]}node(t){if(this._values)return p(this._values,t,{iterables:!0})}override(t,n){if(!this._values)return;const i=t.slice(0,-1),s=t[t.length-1],e=p(this._values,i,{iterables:!0});n?e.set(s,n):e&&e.delete(s)}}},3328:(A,$,v)=>{const l=v(375),p=v(8571),y=v(5277),f=v(1447),t=v(8160),n=v(6354),i=v(6133),s={symbol:Symbol("template"),opens:new Array(1e3).join("\0"),closes:new Array(1e3).join(""),dateFormat:{date:Date.prototype.toDateString,iso:Date.prototype.toISOString,string:Date.prototype.toString,time:Date.prototype.toTimeString,utc:Date.prototype.toUTCString}};A.exports=s.Template=class{constructor(e,o){l(typeof e=="string","Template source must be a string"),l(!e.includes("\0")&&!e.includes(""),"Template source cannot contain reserved control characters"),this.source=e,this.rendered=e,this._template=null,this._settings=p(o),this._parse()}_parse(){if(!this.source.includes("{"))return;const e=s.encode(this.source),o=s.split(e);let r=!1;const a=[],c=o.shift();c&&a.push(c);for(const m of o){const g=m[0]!=="{",_=g?"}":"}}",b=m.indexOf(_);if(b===-1||m[1]==="{"){a.push(`{${s.decode(m)}`);continue}let u=m.slice(g?0:1,b);const h=u[0]===":";h&&(u=u.slice(1));const d=this._ref(s.decode(u),{raw:g,wrapped:h});a.push(d),typeof d!="string"&&(r=!0);const w=m.slice(b+_.length);w&&a.push(s.decode(w))}r?this._template=a:this.rendered=a.join("")}static date(e,o){return s.dateFormat[o.dateFormat].call(e)}describe(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(!this._settings&&e.compact)return this.source;const o={template:this.source};return this._settings&&(o.options=this._settings),o}static build(e){return new s.Template(e.template,e.options)}isDynamic(){return!!this._template}static isTemplate(e){return!!e&&!!e[t.symbols.template]}refs(){if(!this._template)return;const e=[];for(const o of this._template)typeof o!="string"&&e.push(...o.refs);return e}resolve(e,o,r,a){return this._template&&this._template.length===1?this._part(this._template[0],e,o,r,a,{}):this.render(e,o,r,a)}_part(e){for(var o=arguments.length,r=new Array(o>1?o-1:0),a=1;a<o;a++)r[a-1]=arguments[a];return e.ref?e.ref.resolve(...r):e.formula.evaluate(r)}render(e,o,r,a){let c=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{};if(!this.isDynamic())return this.rendered;const m=[];for(const g of this._template)if(typeof g=="string")m.push(g);else{const _=this._part(g,e,o,r,a,c),b=s.stringify(_,e,o,r,a,c);if(b!==void 0){const u=g.raw||(c.errors&&c.errors.escapeHtml)===!1?b:y(b);m.push(s.wrap(u,g.wrapped&&r.errors.wrap.label))}}return m.join("")}_ref(e,o){let{raw:r,wrapped:a}=o;const c=[],m=_=>{const b=i.create(_,this._settings);return c.push(b),u=>b.resolve(...u)};try{var g=new f.Parser(e,{reference:m,functions:s.functions,constants:s.constants})}catch(_){throw _.message=`Invalid template variable "${e}" fails due to: ${_.message}`,_}if(g.single){if(g.single.type==="reference"){const _=c[0];return{ref:_,raw:r,refs:c,wrapped:a||_.type==="local"&&_.key==="label"}}return s.stringify(g.single.value)}return{formula:g,raw:r,refs:c}}toString(){return this.source}},s.Template.prototype[t.symbols.template]=!0,s.Template.prototype.isImmutable=!0,s.encode=function(e){return e.replace(/\\(\{+)/g,(o,r)=>s.opens.slice(0,r.length)).replace(/\\(\}+)/g,(o,r)=>s.closes.slice(0,r.length))},s.decode=function(e){return e.replace(/\u0000/g,"{").replace(/\u0001/g,"}")},s.split=function(e){const o=[];let r="";for(let a=0;a<e.length;++a){const c=e[a];if(c==="{"){let m="";for(;a+1<e.length&&e[a+1]==="{";)m+="{",++a;o.push(r),r=m}else r+=c}return o.push(r),o},s.wrap=function(e,o){return o?o.length===1?`${o}${e}${o}`:`${o[0]}${e}${o[1]}`:e},s.stringify=function(e,o,r,a,c){let m=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{};const g=typeof e,_=a&&a.errors&&a.errors.wrap||{};let b=!1;if(i.isRef(e)&&e.render&&(b=e.in,e=e.resolve(o,r,a,c,{in:e.in,...m})),e===null)return"null";if(g==="string")return s.wrap(e,m.arrayItems&&_.string);if(g==="number"||g==="function"||g==="symbol")return e.toString();if(g!=="object")return JSON.stringify(e);if(e instanceof Date)return s.Template.date(e,a);if(e instanceof Map){const h=[];for(const[d,w]of e.entries())h.push(`${d.toString()} -> ${w.toString()}`);e=h}if(!Array.isArray(e))return e.toString();const u=[];for(const h of e)u.push(s.stringify(h,o,r,a,c,{arrayItems:!0,...m}));return s.wrap(u.join(", "),!b&&_.array)},s.constants={true:!0,false:!1,null:null,second:1e3,minute:6e4,hour:36e5,day:864e5},s.functions={if:(e,o,r)=>e?o:r,length:e=>typeof e=="string"?e.length:e&&typeof e=="object"?Array.isArray(e)?e.length:Object.keys(e).length:null,msg(e){const[o,r,a,c,m]=this,g=m.messages;if(!g)return"";const _=n.template(o,g[0],e,r,a)||n.template(o,g[1],e,r,a);return _?_.render(o,r,a,c,m):""},number:e=>typeof e=="number"?e:typeof e=="string"?parseFloat(e):typeof e=="boolean"?e?1:0:e instanceof Date?e.getTime():null}},4946:(A,$,v)=>{const l=v(375),p=v(1687),y=v(8068),f=v(8160),t=v(3292),n=v(6354),i=v(6133),s={};A.exports=y.extend({type:"alternatives",flags:{match:{default:"any"}},terms:{matches:{init:[],register:i.toSibling}},args(e){for(var o=arguments.length,r=new Array(o>1?o-1:0),a=1;a<o;a++)r[a-1]=arguments[a];return r.length===1&&Array.isArray(r[0])?e.try(...r[0]):e.try(...r)},validate(e,o){const{schema:r,error:a,state:c,prefs:m}=o;if(r._flags.match){const _=[],b=[];for(let h=0;h<r.$_terms.matches.length;++h){const d=r.$_terms.matches[h],w=c.nest(d.schema,`match.${h}`);w.snapshot();const S=d.schema.$_validate(e,w,m);S.errors?(b.push(S.errors),w.restore()):_.push(S.value)}if(_.length===0)return{errors:a("alternatives.any",{details:b.map(h=>n.details(h,{override:!1}))})};if(r._flags.match==="one")return _.length===1?{value:_[0]}:{errors:a("alternatives.one")};if(_.length!==r.$_terms.matches.length)return{errors:a("alternatives.all",{details:b.map(h=>n.details(h,{override:!1}))})};const u=h=>h.$_terms.matches.some(d=>d.schema.type==="object"||d.schema.type==="alternatives"&&u(d.schema));return u(r)?{value:_.reduce((h,d)=>p(h,d,{mergeArrays:!1}))}:{value:_[_.length-1]}}const g=[];for(let _=0;_<r.$_terms.matches.length;++_){const b=r.$_terms.matches[_];if(b.schema){const d=c.nest(b.schema,`match.${_}`);d.snapshot();const w=b.schema.$_validate(e,d,m);if(!w.errors)return w;d.restore(),g.push({schema:b.schema,reports:w.errors});continue}const u=b.ref?b.ref.resolve(e,c,m):e,h=b.is?[b]:b.switch;for(let d=0;d<h.length;++d){const w=h[d],{is:S,then:R,otherwise:E}=w,I=`match.${_}${b.switch?"."+d:""}`;if(S.$_match(u,c.nest(S,`${I}.is`),m)){if(R)return R.$_validate(e,c.nest(R,`${I}.then`),m)}else if(E)return E.$_validate(e,c.nest(E,`${I}.otherwise`),m)}}return s.errors(g,o)},rules:{conditional:{method(e,o){l(!this._flags._endedSwitch,"Unreachable condition"),l(!this._flags.match,"Cannot combine match mode",this._flags.match,"with conditional rule"),l(o.break===void 0,"Cannot use break option with alternatives conditional");const r=this.clone(),a=t.when(r,e,o),c=a.is?[a]:a.switch;for(const m of c)if(m.then&&m.otherwise){r.$_setFlag("_endedSwitch",!0,{clone:!1});break}return r.$_terms.matches.push(a),r.$_mutateRebuild()}},match:{method(e){if(l(["any","one","all"].includes(e),"Invalid alternatives match mode",e),e!=="any")for(const o of this.$_terms.matches)l(o.schema,"Cannot combine match mode",e,"with conditional rules");return this.$_setFlag("match",e)}},try:{method(){for(var e=arguments.length,o=new Array(e),r=0;r<e;r++)o[r]=arguments[r];l(o.length,"Missing alternative schemas"),f.verifyFlat(o,"try"),l(!this._flags._endedSwitch,"Unreachable condition");const a=this.clone();for(const c of o)a.$_terms.matches.push({schema:a.$_compile(c)});return a.$_mutateRebuild()}}},overrides:{label(e){return this.$_parent("label",e).$_modify({each:(o,r)=>r.path[0]!=="is"?o.label(e):void 0,ref:!1})}},rebuild(e){e.$_modify({each:o=>{f.isSchema(o)&&o.type==="array"&&e.$_setFlag("_arrayItems",!0,{clone:!1})}})},manifest:{build(e,o){if(o.matches)for(const r of o.matches){const{schema:a,ref:c,is:m,not:g,then:_,otherwise:b}=r;e=a?e.try(a):c?e.conditional(c,{is:m,then:_,not:g,otherwise:b,switch:r.switch}):e.conditional(m,{then:_,otherwise:b})}return e}},messages:{"alternatives.all":"{{#label}} does not match all of the required types","alternatives.any":"{{#label}} does not match any of the allowed types","alternatives.match":"{{#label}} does not match any of the allowed types","alternatives.one":"{{#label}} matches more than one allowed type","alternatives.types":"{{#label}} must be one of {{#types}}"}}),s.errors=function(e,o){let{error:r,state:a}=o;if(!e.length)return{errors:r("alternatives.any")};if(e.length===1)return{errors:e[0].reports};const c=new Set,m=[];for(const{reports:g,schema:_}of e){if(g.length>1)return s.unmatched(e,r);const b=g[0];if(b instanceof n.Report==0)return s.unmatched(e,r);if(b.state.path.length!==a.path.length){m.push({type:_.type,report:b});continue}if(b.code==="any.only"){for(const d of b.local.valids)c.add(d);continue}const[u,h]=b.code.split(".");h==="base"?c.add(u):m.push({type:_.type,report:b})}return m.length?m.length===1?{errors:m[0].report}:s.unmatched(e,r):{errors:r("alternatives.types",{types:[...c]})}},s.unmatched=function(e,o){const r=[];for(const a of e)r.push(...a.reports);return{errors:o("alternatives.match",n.details(r,{override:!1}))}}},8068:(A,$,v)=>{const l=v(375),p=v(7629),y=v(8160),f=v(6914);A.exports=p.extend({type:"any",flags:{only:{default:!1}},terms:{alterations:{init:null},examples:{init:null},externals:{init:null},metas:{init:[]},notes:{init:[]},shared:{init:null},tags:{init:[]},whens:{init:null}},rules:{custom:{method(t,n){return l(typeof t=="function","Method must be a function"),l(n===void 0||n&&typeof n=="string","Description must be a non-empty string"),this.$_addRule({name:"custom",args:{method:t,description:n}})},validate(t,n,i){let{method:s}=i;try{return s(t,n)}catch(e){return n.error("any.custom",{error:e})}},args:["method","description"],multi:!0},messages:{method(t){return this.prefs({messages:t})}},shared:{method(t){l(y.isSchema(t)&&t._flags.id,"Schema must be a schema with an id");const n=this.clone();return n.$_terms.shared=n.$_terms.shared||[],n.$_terms.shared.push(t),n.$_mutateRegister(t),n}},warning:{method(t,n){return l(t&&typeof t=="string","Invalid warning code"),this.$_addRule({name:"warning",args:{code:t,local:n},warn:!0})},validate(t,n,i){let{code:s,local:e}=i;return n.error(s,e)},args:["code","local"],multi:!0}},modifiers:{keep(t){let n=!(arguments.length>1&&arguments[1]!==void 0)||arguments[1];t.keep=n},message(t,n){t.message=f.compile(n)},warn(t){let n=!(arguments.length>1&&arguments[1]!==void 0)||arguments[1];t.warn=n}},manifest:{build(t,n){for(const i in n){const s=n[i];if(["examples","externals","metas","notes","tags"].includes(i))for(const e of s)t=t[i.slice(0,-1)](e);else if(i!=="alterations")if(i!=="whens"){if(i==="shared")for(const e of s)t=t.shared(e)}else for(const e of s){const{ref:o,is:r,not:a,then:c,otherwise:m,concat:g}=e;t=g?t.concat(g):o?t.when(o,{is:r,not:a,then:c,otherwise:m,switch:e.switch,break:e.break}):t.when(r,{then:c,otherwise:m,break:e.break})}else{const e={};for(const{target:o,adjuster:r}of s)e[o]=r;t=t.alter(e)}}return t}},messages:{"any.custom":"{{#label}} failed custom validation because {{#error.message}}","any.default":"{{#label}} threw an error when running default method","any.failover":"{{#label}} threw an error when running failover method","any.invalid":"{{#label}} contains an invalid value","any.only":'{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',"any.ref":"{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}","any.required":"{{#label}} is required","any.unknown":"{{#label}} is not allowed"}})},546:(A,$,v)=>{const l=v(375),p=v(9474),y=v(9621),f=v(8068),t=v(8160),n=v(3292),i={};A.exports=f.extend({type:"array",flags:{single:{default:!1},sparse:{default:!1}},terms:{items:{init:[],manifest:"schema"},ordered:{init:[],manifest:"schema"},_exclusions:{init:[]},_inclusions:{init:[]},_requireds:{init:[]}},coerce:{from:"object",method(s,e){let{schema:o,state:r,prefs:a}=e;if(!Array.isArray(s))return;const c=o.$_getRule("sort");return c?i.sort(o,s,c.args.options,r,a):void 0}},validate(s,e){let{schema:o,error:r}=e;if(!Array.isArray(s)){if(o._flags.single){const a=[s];return a[t.symbols.arraySingle]=!0,{value:a}}return{errors:r("array.base")}}if(o.$_getRule("items")||o.$_terms.externals)return{value:s.slice()}},rules:{has:{method(s){s=this.$_compile(s,{appendPath:!0});const e=this.$_addRule({name:"has",args:{schema:s}});return e.$_mutateRegister(s),e},validate(s,e,o){let{state:r,prefs:a,error:c}=e,{schema:m}=o;const g=[s,...r.ancestors];for(let b=0;b<s.length;++b){const u=r.localize([...r.path,b],g,m);if(m.$_match(s[b],u,a))return s}const _=m._flags.label;return _?c("array.hasKnown",{patternLabel:_}):c("array.hasUnknown",null)},multi:!0},items:{method(){for(var s=arguments.length,e=new Array(s),o=0;o<s;o++)e[o]=arguments[o];t.verifyFlat(e,"items");const r=this.$_addRule("items");for(let a=0;a<e.length;++a){const c=t.tryWithPath(()=>this.$_compile(e[a]),a,{append:!0});r.$_terms.items.push(c)}return r.$_mutateRebuild()},validate(s,e){let{schema:o,error:r,state:a,prefs:c,errorsArray:m}=e;const g=o.$_terms._requireds.slice(),_=o.$_terms.ordered.slice(),b=[...o.$_terms._inclusions,...g],u=!s[t.symbols.arraySingle];delete s[t.symbols.arraySingle];const h=m();let d=s.length;for(let w=0;w<d;++w){const S=s[w];let R=!1,E=!1;const I=u?w:new Number(w),D=[...a.path,I];if(!o._flags.sparse&&S===void 0){if(h.push(r("array.sparse",{key:I,path:D,pos:w,value:void 0},a.localize(D))),c.abortEarly)return h;_.shift();continue}const C=[s,...a.ancestors];for(const T of o.$_terms._exclusions)if(T.$_match(S,a.localize(D,C,T),c,{presence:"ignore"})){if(h.push(r("array.excludes",{pos:w,value:S},a.localize(D))),c.abortEarly)return h;R=!0,_.shift();break}if(R)continue;if(o.$_terms.ordered.length){if(_.length){const T=_.shift(),N=T.$_validate(S,a.localize(D,C,T),c);if(N.errors){if(h.push(...N.errors),c.abortEarly)return h}else if(T._flags.result==="strip")i.fastSplice(s,w),--w,--d;else{if(!o._flags.sparse&&N.value===void 0){if(h.push(r("array.sparse",{key:I,path:D,pos:w,value:void 0},a.localize(D))),c.abortEarly)return h;continue}s[w]=N.value}continue}if(!o.$_terms.items.length){if(h.push(r("array.orderedLength",{pos:w,limit:o.$_terms.ordered.length})),c.abortEarly)return h;break}}const M=[];let L=g.length;for(let T=0;T<L;++T){const N=a.localize(D,C,g[T]);N.snapshot();const P=g[T].$_validate(S,N,c);if(M[T]=P,!P.errors){if(s[w]=P.value,E=!0,i.fastSplice(g,T),--T,--L,!o._flags.sparse&&P.value===void 0&&(h.push(r("array.sparse",{key:I,path:D,pos:w,value:void 0},a.localize(D))),c.abortEarly))return h;break}N.restore()}if(E)continue;const U=c.stripUnknown&&!!c.stripUnknown.arrays||!1;L=b.length;for(const T of b){let N;const P=g.indexOf(T);if(P!==-1)N=M[P];else{const q=a.localize(D,C,T);if(q.snapshot(),N=T.$_validate(S,q,c),!N.errors){T._flags.result==="strip"?(i.fastSplice(s,w),--w,--d):o._flags.sparse||N.value!==void 0?s[w]=N.value:(h.push(r("array.sparse",{key:I,path:D,pos:w,value:void 0},a.localize(D))),R=!0),E=!0;break}q.restore()}if(L===1){if(U){i.fastSplice(s,w),--w,--d,E=!0;break}if(h.push(...N.errors),c.abortEarly)return h;R=!0;break}}if(!R&&(o.$_terms._inclusions.length||o.$_terms._requireds.length)&&!E){if(U){i.fastSplice(s,w),--w,--d;continue}if(h.push(r("array.includes",{pos:w,value:S},a.localize(D))),c.abortEarly)return h}}return g.length&&i.fillMissedErrors(o,h,g,s,a,c),_.length&&(i.fillOrderedErrors(o,h,_,s,a,c),h.length||i.fillDefault(_,s,a,c)),h.length?h:s},priority:!0,manifest:!1},length:{method(s){return this.$_addRule({name:"length",args:{limit:s},operator:"="})},validate(s,e,o,r){let{limit:a}=o,{name:c,operator:m,args:g}=r;return t.compare(s.length,a,m)?s:e.error("array."+c,{limit:g.limit,value:s})},args:[{name:"limit",ref:!0,assert:t.limit,message:"must be a positive integer"}]},max:{method(s){return this.$_addRule({name:"max",method:"length",args:{limit:s},operator:"<="})}},min:{method(s){return this.$_addRule({name:"min",method:"length",args:{limit:s},operator:">="})}},ordered:{method(){for(var s=arguments.length,e=new Array(s),o=0;o<s;o++)e[o]=arguments[o];t.verifyFlat(e,"ordered");const r=this.$_addRule("items");for(let a=0;a<e.length;++a){const c=t.tryWithPath(()=>this.$_compile(e[a]),a,{append:!0});i.validateSingle(c,r),r.$_mutateRegister(c),r.$_terms.ordered.push(c)}return r.$_mutateRebuild()}},single:{method(s){const e=s===void 0||!!s;return l(!e||!this._flags._arrayItems,"Cannot specify single rule when array has array items"),this.$_setFlag("single",e)}},sort:{method(){let s=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};t.assertOptions(s,["by","order"]);const e={order:s.order||"ascending"};return s.by&&(e.by=n.ref(s.by,{ancestor:0}),l(!e.by.ancestor,"Cannot sort by ancestor")),this.$_addRule({name:"sort",args:{options:e}})},validate(s,e,o){let{error:r,state:a,prefs:c,schema:m}=e,{options:g}=o;const{value:_,errors:b}=i.sort(m,s,g,a,c);if(b)return b;for(let u=0;u<s.length;++u)if(s[u]!==_[u])return r("array.sort",{order:g.order,by:g.by?g.by.key:"value"});return s},convert:!0},sparse:{method(s){const e=s===void 0||!!s;return this._flags.sparse===e?this:(e?this.clone():this.$_addRule("items")).$_setFlag("sparse",e,{clone:!1})}},unique:{method(s){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};l(!s||typeof s=="function"||typeof s=="string","comparator must be a function or a string"),t.assertOptions(e,["ignoreUndefined","separator"]);const o={name:"unique",args:{options:e,comparator:s}};if(s)if(typeof s=="string"){const r=t.default(e.separator,".");o.path=r?s.split(r):[s]}else o.comparator=s;return this.$_addRule(o)},validate(s,e,o,r){let{state:a,error:c,schema:m}=e,{comparator:g,options:_}=o,{comparator:b,path:u}=r;const h={string:Object.create(null),number:Object.create(null),undefined:Object.create(null),boolean:Object.create(null),object:new Map,function:new Map,custom:new Map},d=b||p,w=_.ignoreUndefined;for(let S=0;S<s.length;++S){const R=u?y(s[S],u):s[S],E=b?h.custom:h[typeof R];if(l(E,"Failed to find unique map container for type",typeof R),E instanceof Map){const I=E.entries();let D;for(;!(D=I.next()).done;)if(d(D.value[0],R)){const C=a.localize([...a.path,S],[s,...a.ancestors]),M={pos:S,value:s[S],dupePos:D.value[1],dupeValue:s[D.value[1]]};return u&&(M.path=g),c("array.unique",M,C)}E.set(R,S)}else{if((!w||R!==void 0)&&E[R]!==void 0){const I={pos:S,value:s[S],dupePos:E[R],dupeValue:s[E[R]]};return u&&(I.path=g),c("array.unique",I,a.localize([...a.path,S],[s,...a.ancestors]))}E[R]=S}}return s},args:["comparator","options"],multi:!0}},cast:{set:{from:Array.isArray,to:(s,e)=>new Set(s)}},rebuild(s){s.$_terms._inclusions=[],s.$_terms._exclusions=[],s.$_terms._requireds=[];for(const e of s.$_terms.items)i.validateSingle(e,s),e._flags.presence==="required"?s.$_terms._requireds.push(e):e._flags.presence==="forbidden"?s.$_terms._exclusions.push(e):s.$_terms._inclusions.push(e);for(const e of s.$_terms.ordered)i.validateSingle(e,s)},manifest:{build:(s,e)=>(e.items&&(s=s.items(...e.items)),e.ordered&&(s=s.ordered(...e.ordered)),s)},messages:{"array.base":"{{#label}} must be an array","array.excludes":"{{#label}} contains an excluded value","array.hasKnown":"{{#label}} does not contain at least one required match for type {:#patternLabel}","array.hasUnknown":"{{#label}} does not contain at least one required match","array.includes":"{{#label}} does not match any of the allowed types","array.includesRequiredBoth":"{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)","array.includesRequiredKnowns":"{{#label}} does not contain {{#knownMisses}}","array.includesRequiredUnknowns":"{{#label}} does not contain {{#unknownMisses}} required value(s)","array.length":"{{#label}} must contain {{#limit}} items","array.max":"{{#label}} must contain less than or equal to {{#limit}} items","array.min":"{{#label}} must contain at least {{#limit}} items","array.orderedLength":"{{#label}} must contain at most {{#limit}} items","array.sort":"{{#label}} must be sorted in {#order} order by {{#by}}","array.sort.mismatching":"{{#label}} cannot be sorted due to mismatching types","array.sort.unsupported":"{{#label}} cannot be sorted due to unsupported type {#type}","array.sparse":"{{#label}} must not be a sparse array item","array.unique":"{{#label}} contains a duplicate value"}}),i.fillMissedErrors=function(s,e,o,r,a,c){const m=[];let g=0;for(const _ of o){const b=_._flags.label;b?m.push(b):++g}m.length?g?e.push(s.$_createError("array.includesRequiredBoth",r,{knownMisses:m,unknownMisses:g},a,c)):e.push(s.$_createError("array.includesRequiredKnowns",r,{knownMisses:m},a,c)):e.push(s.$_createError("array.includesRequiredUnknowns",r,{unknownMisses:g},a,c))},i.fillOrderedErrors=function(s,e,o,r,a,c){const m=[];for(const g of o)g._flags.presence==="required"&&m.push(g);m.length&&i.fillMissedErrors(s,e,m,r,a,c)},i.fillDefault=function(s,e,o,r){const a=[];let c=!0;for(let m=s.length-1;m>=0;--m){const g=s[m],_=[e,...o.ancestors],b=g.$_validate(void 0,o.localize(o.path,_,g),r).value;if(c){if(b===void 0)continue;c=!1}a.unshift(b)}a.length&&e.push(...a)},i.fastSplice=function(s,e){let o=e;for(;o<s.length;)s[o++]=s[o];--s.length},i.validateSingle=function(s,e){(s.type==="array"||s._flags._arrayItems)&&(l(!e._flags.single,"Cannot specify array item with single rule enabled"),e.$_setFlag("_arrayItems",!0,{clone:!1}))},i.sort=function(s,e,o,r,a){const c=o.order==="ascending"?1:-1,m=-1*c,g=c,_=(b,u)=>{let h=i.compare(b,u,m,g);if(h!==null||(o.by&&(b=o.by.resolve(b,r,a),u=o.by.resolve(u,r,a)),h=i.compare(b,u,m,g),h!==null))return h;const d=typeof b;if(d!==typeof u)throw s.$_createError("array.sort.mismatching",e,null,r,a);if(d!=="number"&&d!=="string")throw s.$_createError("array.sort.unsupported",e,{type:d},r,a);return d==="number"?(b-u)*c:b<u?m:g};try{return{value:e.slice().sort(_)}}catch(b){return{errors:b}}},i.compare=function(s,e,o,r){return s===e?0:s===void 0?1:e===void 0?-1:s===null?r:e===null?o:null}},4937:(A,$,v)=>{const l=v(375),p=v(8068),y=v(8160),f=v(2036),t={isBool:function(n){return typeof n=="boolean"}};A.exports=p.extend({type:"boolean",flags:{sensitive:{default:!1}},terms:{falsy:{init:null,manifest:"values"},truthy:{init:null,manifest:"values"}},coerce(n,i){let{schema:s}=i;if(typeof n!="boolean"){if(typeof n=="string"){const e=s._flags.sensitive?n:n.toLowerCase();n=e==="true"||e!=="false"&&n}return typeof n!="boolean"&&(n=s.$_terms.truthy&&s.$_terms.truthy.has(n,null,null,!s._flags.sensitive)||(!s.$_terms.falsy||!s.$_terms.falsy.has(n,null,null,!s._flags.sensitive))&&n),{value:n}}},validate(n,i){let{error:s}=i;if(typeof n!="boolean")return{value:n,errors:s("boolean.base")}},rules:{truthy:{method(){for(var n=arguments.length,i=new Array(n),s=0;s<n;s++)i[s]=arguments[s];y.verifyFlat(i,"truthy");const e=this.clone();e.$_terms.truthy=e.$_terms.truthy||new f;for(let o=0;o<i.length;++o){const r=i[o];l(r!==void 0,"Cannot call truthy with undefined"),e.$_terms.truthy.add(r)}return e}},falsy:{method(){for(var n=arguments.length,i=new Array(n),s=0;s<n;s++)i[s]=arguments[s];y.verifyFlat(i,"falsy");const e=this.clone();e.$_terms.falsy=e.$_terms.falsy||new f;for(let o=0;o<i.length;++o){const r=i[o];l(r!==void 0,"Cannot call falsy with undefined"),e.$_terms.falsy.add(r)}return e}},sensitive:{method(){let n=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return this.$_setFlag("sensitive",n)}}},cast:{number:{from:t.isBool,to:(n,i)=>n?1:0},string:{from:t.isBool,to:(n,i)=>n?"true":"false"}},manifest:{build:(n,i)=>(i.truthy&&(n=n.truthy(...i.truthy)),i.falsy&&(n=n.falsy(...i.falsy)),n)},messages:{"boolean.base":"{{#label}} must be a boolean"}})},7500:(A,$,v)=>{const l=v(375),p=v(8068),y=v(8160),f=v(3328),t={isDate:function(n){return n instanceof Date}};A.exports=p.extend({type:"date",coerce:{from:["number","string"],method(n,i){let{schema:s}=i;return{value:t.parse(n,s._flags.format)||n}}},validate(n,i){let{schema:s,error:e,prefs:o}=i;if(n instanceof Date&&!isNaN(n.getTime()))return;const r=s._flags.format;return o.convert&&r&&typeof n=="string"?{value:n,errors:e("date.format",{format:r})}:{value:n,errors:e("date.base")}},rules:{compare:{method:!1,validate(n,i,s,e){let{date:o}=s,{name:r,operator:a,args:c}=e;const m=o==="now"?Date.now():o.getTime();return y.compare(n.getTime(),m,a)?n:i.error("date."+r,{limit:c.date,value:n})},args:[{name:"date",ref:!0,normalize:n=>n==="now"?n:t.parse(n),assert:n=>n!==null,message:"must have a valid date format"}]},format:{method(n){return l(["iso","javascript","unix"].includes(n),"Unknown date format",n),this.$_setFlag("format",n)}},greater:{method(n){return this.$_addRule({name:"greater",method:"compare",args:{date:n},operator:">"})}},iso:{method(){return this.format("iso")}},less:{method(n){return this.$_addRule({name:"less",method:"compare",args:{date:n},operator:"<"})}},max:{method(n){return this.$_addRule({name:"max",method:"compare",args:{date:n},operator:"<="})}},min:{method(n){return this.$_addRule({name:"min",method:"compare",args:{date:n},operator:">="})}},timestamp:{method(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"javascript";return l(["javascript","unix"].includes(n),'"type" must be one of "javascript, unix"'),this.format(n)}}},cast:{number:{from:t.isDate,to:(n,i)=>n.getTime()},string:{from:t.isDate,to(n,i){let{prefs:s}=i;return f.date(n,s)}}},messages:{"date.base":"{{#label}} must be a valid date","date.format":'{{#label}} must be in {msg("date.format." + #format) || #format} format',"date.greater":"{{#label}} must be greater than {{:#limit}}","date.less":"{{#label}} must be less than {{:#limit}}","date.max":"{{#label}} must be less than or equal to {{:#limit}}","date.min":"{{#label}} must be greater than or equal to {{:#limit}}","date.format.iso":"ISO 8601 date","date.format.javascript":"timestamp or number of milliseconds","date.format.unix":"timestamp or number of seconds"}}),t.parse=function(n,i){if(n instanceof Date)return n;if(typeof n!="string"&&(isNaN(n)||!isFinite(n))||/^\s*$/.test(n))return null;if(i==="iso")return y.isIsoDate(n)?t.date(n.toString()):null;const s=n;if(typeof n=="string"&&/^[+-]?\d+(\.\d+)?$/.test(n)&&(n=parseFloat(n)),i){if(i==="javascript")return t.date(1*n);if(i==="unix")return t.date(1e3*n);if(typeof s=="string")return null}return t.date(n)},t.date=function(n){const i=new Date(n);return isNaN(i.getTime())?null:i}},390:(A,$,v)=>{const l=v(375),p=v(7824);A.exports=p.extend({type:"function",properties:{typeof:"function"},rules:{arity:{method(y){return l(Number.isSafeInteger(y)&&y>=0,"n must be a positive integer"),this.$_addRule({name:"arity",args:{n:y}})},validate(y,f,t){let{n}=t;return y.length===n?y:f.error("function.arity",{n})}},class:{method(){return this.$_addRule("class")},validate:(y,f)=>/^\s*class\s/.test(y.toString())?y:f.error("function.class",{value:y})},minArity:{method(y){return l(Number.isSafeInteger(y)&&y>0,"n must be a strict positive integer"),this.$_addRule({name:"minArity",args:{n:y}})},validate(y,f,t){let{n}=t;return y.length>=n?y:f.error("function.minArity",{n})}},maxArity:{method(y){return l(Number.isSafeInteger(y)&&y>=0,"n must be a positive integer"),this.$_addRule({name:"maxArity",args:{n:y}})},validate(y,f,t){let{n}=t;return y.length<=n?y:f.error("function.maxArity",{n})}}},messages:{"function.arity":"{{#label}} must have an arity of {{#n}}","function.class":"{{#label}} must be a class","function.maxArity":"{{#label}} must have an arity lesser or equal to {{#n}}","function.minArity":"{{#label}} must have an arity greater or equal to {{#n}}"}})},7824:(A,$,v)=>{const l=v(978),p=v(375),y=v(8571),f=v(3652),t=v(8068),n=v(8160),i=v(3292),s=v(6354),e=v(6133),o=v(3328),r={renameDefaults:{alias:!1,multiple:!1,override:!1}};A.exports=t.extend({type:"_keys",properties:{typeof:"object"},flags:{unknown:{default:!1}},terms:{dependencies:{init:null},keys:{init:null,manifest:{mapped:{from:"schema",to:"key"}}},patterns:{init:null},renames:{init:null}},args:(a,c)=>a.keys(c),validate(a,c){let{schema:m,error:g,state:_,prefs:b}=c;if(!a||typeof a!==m.$_property("typeof")||Array.isArray(a))return{value:a,errors:g("object.base",{type:m.$_property("typeof")})};if(!(m.$_terms.renames||m.$_terms.dependencies||m.$_terms.keys||m.$_terms.patterns||m.$_terms.externals))return;a=r.clone(a,b);const u=[];if(m.$_terms.renames&&!r.rename(m,a,_,b,u))return{value:a,errors:u};if(!m.$_terms.keys&&!m.$_terms.patterns&&!m.$_terms.dependencies)return{value:a,errors:u};const h=new Set(Object.keys(a));if(m.$_terms.keys){const d=[a,..._.ancestors];for(const w of m.$_terms.keys){const S=w.key,R=a[S];h.delete(S);const E=_.localize([..._.path,S],d,w),I=w.schema.$_validate(R,E,b);if(I.errors){if(b.abortEarly)return{value:a,errors:I.errors};I.value!==void 0&&(a[S]=I.value),u.push(...I.errors)}else w.schema._flags.result==="strip"||I.value===void 0&&R!==void 0?delete a[S]:I.value!==void 0&&(a[S]=I.value)}}if(h.size||m._flags._hasPatternMatch){const d=r.unknown(m,a,h,u,_,b);if(d)return d}if(m.$_terms.dependencies)for(const d of m.$_terms.dependencies){if(d.key!==null&&r.isPresent(d.options)(d.key.resolve(a,_,b,null,{shadow:!1}))===!1)continue;const w=r.dependencies[d.rel](m,d,a,_,b);if(w){const S=m.$_createError(w.code,a,w.context,_,b);if(b.abortEarly)return{value:a,errors:S};u.push(S)}}return{value:a,errors:u}},rules:{and:{method(){for(var a=arguments.length,c=new Array(a),m=0;m<a;m++)c[m]=arguments[m];return n.verifyFlat(c,"and"),r.dependency(this,"and",null,c)}},append:{method(a){return a==null||Object.keys(a).length===0?this:this.keys(a)}},assert:{method(a,c,m){o.isTemplate(a)||(a=i.ref(a)),p(m===void 0||typeof m=="string","Message must be a string"),c=this.$_compile(c,{appendPath:!0});const g=this.$_addRule({name:"assert",args:{subject:a,schema:c,message:m}});return g.$_mutateRegister(a),g.$_mutateRegister(c),g},validate(a,c,m){let{error:g,prefs:_,state:b}=c,{subject:u,schema:h,message:d}=m;const w=u.resolve(a,b,_),S=e.isRef(u)?u.absolute(b):[];return h.$_match(w,b.localize(S,[a,...b.ancestors],h),_)?a:g("object.assert",{subject:u,message:d})},args:["subject","schema","message"],multi:!0},instance:{method(a,c){return p(typeof a=="function","constructor must be a function"),c=c||a.name,this.$_addRule({name:"instance",args:{constructor:a,name:c}})},validate(a,c,m){let{constructor:g,name:_}=m;return a instanceof g?a:c.error("object.instance",{type:_,value:a})},args:["constructor","name"]},keys:{method(a){p(a===void 0||typeof a=="object","Object schema must be a valid object"),p(!n.isSchema(a),"Object schema cannot be a joi schema");const c=this.clone();if(a)if(Object.keys(a).length){c.$_terms.keys=c.$_terms.keys?c.$_terms.keys.filter(m=>!a.hasOwnProperty(m.key)):new r.Keys;for(const m in a)n.tryWithPath(()=>c.$_terms.keys.push({key:m,schema:this.$_compile(a[m])}),m)}else c.$_terms.keys=new r.Keys;else c.$_terms.keys=null;return c.$_mutateRebuild()}},length:{method(a){return this.$_addRule({name:"length",args:{limit:a},operator:"="})},validate(a,c,m,g){let{limit:_}=m,{name:b,operator:u,args:h}=g;return n.compare(Object.keys(a).length,_,u)?a:c.error("object."+b,{limit:h.limit,value:a})},args:[{name:"limit",ref:!0,assert:n.limit,message:"must be a positive integer"}]},max:{method(a){return this.$_addRule({name:"max",method:"length",args:{limit:a},operator:"<="})}},min:{method(a){return this.$_addRule({name:"min",method:"length",args:{limit:a},operator:">="})}},nand:{method(){for(var a=arguments.length,c=new Array(a),m=0;m<a;m++)c[m]=arguments[m];return n.verifyFlat(c,"nand"),r.dependency(this,"nand",null,c)}},or:{method(){for(var a=arguments.length,c=new Array(a),m=0;m<a;m++)c[m]=arguments[m];return n.verifyFlat(c,"or"),r.dependency(this,"or",null,c)}},oxor:{method(){for(var a=arguments.length,c=new Array(a),m=0;m<a;m++)c[m]=arguments[m];return r.dependency(this,"oxor",null,c)}},pattern:{method(a,c){let m=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const g=a instanceof RegExp;g||(a=this.$_compile(a,{appendPath:!0})),p(c!==void 0,"Invalid rule"),n.assertOptions(m,["fallthrough","matches"]),g&&p(!a.flags.includes("g")&&!a.flags.includes("y"),"pattern should not use global or sticky mode"),c=this.$_compile(c,{appendPath:!0});const _=this.clone();_.$_terms.patterns=_.$_terms.patterns||[];const b={[g?"regex":"schema"]:a,rule:c};return m.matches&&(b.matches=this.$_compile(m.matches),b.matches.type!=="array"&&(b.matches=b.matches.$_root.array().items(b.matches)),_.$_mutateRegister(b.matches),_.$_setFlag("_hasPatternMatch",!0,{clone:!1})),m.fallthrough&&(b.fallthrough=!0),_.$_terms.patterns.push(b),_.$_mutateRegister(c),_}},ref:{method(){return this.$_addRule("ref")},validate:(a,c)=>e.isRef(a)?a:c.error("object.refType",{value:a})},regex:{method(){return this.$_addRule("regex")},validate:(a,c)=>a instanceof RegExp?a:c.error("object.regex",{value:a})},rename:{method(a,c){let m=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};p(typeof a=="string"||a instanceof RegExp,"Rename missing the from argument"),p(typeof c=="string"||c instanceof o,"Invalid rename to argument"),p(c!==a,"Cannot rename key to same name:",a),n.assertOptions(m,["alias","ignoreUndefined","override","multiple"]);const g=this.clone();g.$_terms.renames=g.$_terms.renames||[];for(const _ of g.$_terms.renames)p(_.from!==a,"Cannot rename the same key multiple times");return c instanceof o&&g.$_mutateRegister(c),g.$_terms.renames.push({from:a,to:c,options:l(r.renameDefaults,m)}),g}},schema:{method(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"any";return this.$_addRule({name:"schema",args:{type:a}})},validate(a,c,m){let{type:g}=m;return!n.isSchema(a)||g!=="any"&&a.type!==g?c.error("object.schema",{type:g}):a}},unknown:{method(a){return this.$_setFlag("unknown",a!==!1)}},with:{method(a,c){let m=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return r.dependency(this,"with",a,c,m)}},without:{method(a,c){let m=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return r.dependency(this,"without",a,c,m)}},xor:{method(){for(var a=arguments.length,c=new Array(a),m=0;m<a;m++)c[m]=arguments[m];return n.verifyFlat(c,"xor"),r.dependency(this,"xor",null,c)}}},overrides:{default(a,c){return a===void 0&&(a=n.symbols.deepDefault),this.$_parent("default",a,c)}},rebuild(a){if(a.$_terms.keys){const c=new f.Sorter;for(const m of a.$_terms.keys)n.tryWithPath(()=>c.add(m,{after:m.schema.$_rootReferences(),group:m.key}),m.key);a.$_terms.keys=new r.Keys(...c.nodes)}},manifest:{build(a,c){if(c.keys&&(a=a.keys(c.keys)),c.dependencies)for(const{rel:m,key:g=null,peers:_,options:b}of c.dependencies)a=r.dependency(a,m,g,_,b);if(c.patterns)for(const{regex:m,schema:g,rule:_,fallthrough:b,matches:u}of c.patterns)a=a.pattern(m||g,_,{fallthrough:b,matches:u});if(c.renames)for(const{from:m,to:g,options:_}of c.renames)a=a.rename(m,g,_);return a}},messages:{"object.and":"{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}","object.assert":'{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',"object.base":"{{#label}} must be of type {{#type}}","object.instance":"{{#label}} must be an instance of {{:#type}}","object.length":'{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',"object.max":'{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',"object.min":'{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',"object.missing":"{{#label}} must contain at least one of {{#peersWithLabels}}","object.nand":"{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}","object.oxor":"{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}","object.pattern.match":"{{#label}} keys failed to match pattern requirements","object.refType":"{{#label}} must be a Joi reference","object.regex":"{{#label}} must be a RegExp object","object.rename.multiple":"{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}","object.rename.override":"{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists","object.schema":"{{#label}} must be a Joi schema of {{#type}} type","object.unknown":"{{#label}} is not allowed","object.with":"{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}","object.without":"{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}","object.xor":"{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"}}),r.clone=function(a,c){if(typeof a=="object"){if(c.nonEnumerables)return y(a,{shallow:!0});const g=Object.create(Object.getPrototypeOf(a));return Object.assign(g,a),g}const m=function(){for(var g=arguments.length,_=new Array(g),b=0;b<g;b++)_[b]=arguments[b];return a.apply(this,_)};return m.prototype=y(a.prototype),Object.defineProperty(m,"name",{value:a.name,writable:!1}),Object.defineProperty(m,"length",{value:a.length,writable:!1}),Object.assign(m,a),m},r.dependency=function(a,c,m,g,_){p(m===null||typeof m=="string",c,"key must be a strings"),_||(_=g.length>1&&typeof g[g.length-1]=="object"?g.pop():{}),n.assertOptions(_,["separator","isPresent"]),g=[].concat(g);const b=n.default(_.separator,"."),u=[];for(const d of g)p(typeof d=="string",c,"peers must be strings"),u.push(i.ref(d,{separator:b,ancestor:0,prefix:!1}));m!==null&&(m=i.ref(m,{separator:b,ancestor:0,prefix:!1}));const h=a.clone();return h.$_terms.dependencies=h.$_terms.dependencies||[],h.$_terms.dependencies.push(new r.Dependency(c,m,u,g,_)),h},r.dependencies={and(a,c,m,g,_){const b=[],u=[],h=c.peers.length,d=r.isPresent(c.options);for(const w of c.peers)d(w.resolve(m,g,_,null,{shadow:!1}))===!1?b.push(w.key):u.push(w.key);if(b.length!==h&&u.length!==h)return{code:"object.and",context:{present:u,presentWithLabels:r.keysToLabels(a,u),missing:b,missingWithLabels:r.keysToLabels(a,b)}}},nand(a,c,m,g,_){const b=[],u=r.isPresent(c.options);for(const w of c.peers)u(w.resolve(m,g,_,null,{shadow:!1}))&&b.push(w.key);if(b.length!==c.peers.length)return;const h=c.paths[0],d=c.paths.slice(1);return{code:"object.nand",context:{main:h,mainWithLabel:r.keysToLabels(a,h),peers:d,peersWithLabels:r.keysToLabels(a,d)}}},or(a,c,m,g,_){const b=r.isPresent(c.options);for(const u of c.peers)if(b(u.resolve(m,g,_,null,{shadow:!1})))return;return{code:"object.missing",context:{peers:c.paths,peersWithLabels:r.keysToLabels(a,c.paths)}}},oxor(a,c,m,g,_){const b=[],u=r.isPresent(c.options);for(const d of c.peers)u(d.resolve(m,g,_,null,{shadow:!1}))&&b.push(d.key);if(!b.length||b.length===1)return;const h={peers:c.paths,peersWithLabels:r.keysToLabels(a,c.paths)};return h.present=b,h.presentWithLabels=r.keysToLabels(a,b),{code:"object.oxor",context:h}},with(a,c,m,g,_){const b=r.isPresent(c.options);for(const u of c.peers)if(b(u.resolve(m,g,_,null,{shadow:!1}))===!1)return{code:"object.with",context:{main:c.key.key,mainWithLabel:r.keysToLabels(a,c.key.key),peer:u.key,peerWithLabel:r.keysToLabels(a,u.key)}}},without(a,c,m,g,_){const b=r.isPresent(c.options);for(const u of c.peers)if(b(u.resolve(m,g,_,null,{shadow:!1})))return{code:"object.without",context:{main:c.key.key,mainWithLabel:r.keysToLabels(a,c.key.key),peer:u.key,peerWithLabel:r.keysToLabels(a,u.key)}}},xor(a,c,m,g,_){const b=[],u=r.isPresent(c.options);for(const d of c.peers)u(d.resolve(m,g,_,null,{shadow:!1}))&&b.push(d.key);if(b.length===1)return;const h={peers:c.paths,peersWithLabels:r.keysToLabels(a,c.paths)};return b.length===0?{code:"object.missing",context:h}:(h.present=b,h.presentWithLabels=r.keysToLabels(a,b),{code:"object.xor",context:h})}},r.keysToLabels=function(a,c){return Array.isArray(c)?c.map(m=>a.$_mapLabels(m)):a.$_mapLabels(c)},r.isPresent=function(a){return typeof a.isPresent=="function"?a.isPresent:c=>c!==void 0},r.rename=function(a,c,m,g,_){const b={};for(const u of a.$_terms.renames){const h=[],d=typeof u.from!="string";if(d)for(const w in c){if(c[w]===void 0&&u.options.ignoreUndefined||w===u.to)continue;const S=u.from.exec(w);S&&h.push({from:w,to:u.to,match:S})}else!Object.prototype.hasOwnProperty.call(c,u.from)||c[u.from]===void 0&&u.options.ignoreUndefined||h.push(u);for(const w of h){const S=w.from;let R=w.to;if(R instanceof o&&(R=R.render(c,m,g,w.match)),S!==R){if(!u.options.multiple&&b[R]&&(_.push(a.$_createError("object.rename.multiple",c,{from:S,to:R,pattern:d},m,g)),g.abortEarly)||Object.prototype.hasOwnProperty.call(c,R)&&!u.options.override&&!b[R]&&(_.push(a.$_createError("object.rename.override",c,{from:S,to:R,pattern:d},m,g)),g.abortEarly))return!1;c[S]===void 0?delete c[R]:c[R]=c[S],b[R]=!0,u.options.alias||delete c[S]}}}return!0},r.unknown=function(a,c,m,g,_,b){if(a.$_terms.patterns){let u=!1;const h=a.$_terms.patterns.map(w=>{if(w.matches)return u=!0,[]}),d=[c,..._.ancestors];for(const w of m){const S=c[w],R=[..._.path,w];for(let E=0;E<a.$_terms.patterns.length;++E){const I=a.$_terms.patterns[E];if(I.regex){const M=I.regex.test(w);if(_.mainstay.tracer.debug(_,"rule",`pattern.${E}`,M?"pass":"error"),!M)continue}else if(!I.schema.$_match(w,_.nest(I.schema,`pattern.${E}`),b))continue;m.delete(w);const D=_.localize(R,d,{schema:I.rule,key:w}),C=I.rule.$_validate(S,D,b);if(C.errors){if(b.abortEarly)return{value:c,errors:C.errors};g.push(...C.errors)}if(I.matches&&h[E].push(w),c[w]=C.value,!I.fallthrough)break}}if(u)for(let w=0;w<h.length;++w){const S=h[w];if(!S)continue;const R=a.$_terms.patterns[w].matches,E=_.localize(_.path,d,R),I=R.$_validate(S,E,b);if(I.errors){const D=s.details(I.errors,{override:!1});D.matches=S;const C=a.$_createError("object.pattern.match",c,D,_,b);if(b.abortEarly)return{value:c,errors:C};g.push(C)}}}if(m.size&&(a.$_terms.keys||a.$_terms.patterns)){if(b.stripUnknown&&!a._flags.unknown||b.skipFunctions){const u=!(!b.stripUnknown||b.stripUnknown!==!0&&!b.stripUnknown.objects);for(const h of m)u?(delete c[h],m.delete(h)):typeof c[h]=="function"&&m.delete(h)}if(!n.default(a._flags.unknown,b.allowUnknown))for(const u of m){const h=_.localize([..._.path,u],[]),d=a.$_createError("object.unknown",c[u],{child:u},h,b,{flags:!1});if(b.abortEarly)return{value:c,errors:d};g.push(d)}}},r.Dependency=class{constructor(a,c,m,g,_){this.rel=a,this.key=c,this.peers=m,this.paths=g,this.options=_}describe(){const a={rel:this.rel,peers:this.paths};return this.key!==null&&(a.key=this.key.key),this.peers[0].separator!=="."&&(a.options={...a.options,separator:this.peers[0].separator}),this.options.isPresent&&(a.options={...a.options,isPresent:this.options.isPresent}),a}},r.Keys=class extends Array{concat(a){const c=this.slice(),m=new Map;for(let g=0;g<c.length;++g)m.set(c[g].key,g);for(const g of a){const _=g.key,b=m.get(_);b!==void 0?c[b]={key:_,schema:c[b].schema.concat(g.schema)}:c.push(g)}return c}}},8785:(A,$,v)=>{const l=v(375),p=v(8068),y=v(8160),f=v(3292),t=v(6354),n={};A.exports=p.extend({type:"link",properties:{schemaChain:!0},terms:{link:{init:null,manifest:"single",register:!1}},args:(i,s)=>i.ref(s),validate(i,s){let{schema:e,state:o,prefs:r}=s;l(e.$_terms.link,"Uninitialized link schema");const a=n.generate(e,i,o,r),c=e.$_terms.link[0].ref;return a.$_validate(i,o.nest(a,`link:${c.display}:${a.type}`),r)},generate:(i,s,e,o)=>n.generate(i,s,e,o),rules:{ref:{method(i){l(!this.$_terms.link,"Cannot reinitialize schema"),i=f.ref(i),l(i.type==="value"||i.type==="local","Invalid reference type:",i.type),l(i.type==="local"||i.ancestor==="root"||i.ancestor>0,"Link cannot reference itself");const s=this.clone();return s.$_terms.link=[{ref:i}],s}},relative:{method(){let i=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return this.$_setFlag("relative",i)}}},overrides:{concat(i){l(this.$_terms.link,"Uninitialized link schema"),l(y.isSchema(i),"Invalid schema object"),l(i.type!=="link","Cannot merge type link with another link");const s=this.clone();return s.$_terms.whens||(s.$_terms.whens=[]),s.$_terms.whens.push({concat:i}),s.$_mutateRebuild()}},manifest:{build:(i,s)=>(l(s.link,"Invalid link description missing link"),i.ref(s.link))}}),n.generate=function(i,s,e,o){let r=e.mainstay.links.get(i);if(r)return r._generate(s,e,o).schema;const a=i.$_terms.link[0].ref,{perspective:c,path:m}=n.perspective(a,e);n.assert(c,"which is outside of schema boundaries",a,i,e,o);try{r=m.length?c.$_reach(m):c}catch{n.assert(!1,"to non-existing schema",a,i,e,o)}return n.assert(r.type!=="link","which is another link",a,i,e,o),i._flags.relative||e.mainstay.links.set(i,r),r._generate(s,e,o).schema},n.perspective=function(i,s){if(i.type==="local"){for(const{schema:e,key:o}of s.schemas){if((e._flags.id||o)===i.path[0])return{perspective:e,path:i.path.slice(1)};if(e.$_terms.shared){for(const r of e.$_terms.shared)if(r._flags.id===i.path[0])return{perspective:r,path:i.path.slice(1)}}}return{perspective:null,path:null}}return i.ancestor==="root"?{perspective:s.schemas[s.schemas.length-1].schema,path:i.path}:{perspective:s.schemas[i.ancestor]&&s.schemas[i.ancestor].schema,path:i.path}},n.assert=function(i,s,e,o,r,a){i||l(!1,`"${t.label(o._flags,r,a)}" contains link reference "${e.display}" ${s}`)}},3832:(A,$,v)=>{const l=v(375),p=v(8068),y=v(8160),f={numberRx:/^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,precisionRx:/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,exponentialPartRegex:/[eE][+-]?\d+$/,leadingSignAndZerosRegex:/^[+-]?(0*)?/,dotRegex:/\./,trailingZerosRegex:/0+$/};A.exports=p.extend({type:"number",flags:{unsafe:{default:!1}},coerce:{from:"string",method(t,n){let{schema:i,error:s}=n;if(!t.match(f.numberRx))return;t=t.trim();const e={value:parseFloat(t)};if(e.value===0&&(e.value=0),!i._flags.unsafe)if(t.match(/e/i)){if(f.extractSignificantDigits(t)!==f.extractSignificantDigits(String(e.value)))return e.errors=s("number.unsafe"),e}else{const o=e.value.toString();if(o.match(/e/i))return e;if(o!==f.normalizeDecimal(t))return e.errors=s("number.unsafe"),e}return e}},validate(t,n){let{schema:i,error:s,prefs:e}=n;if(t===1/0||t===-1/0)return{value:t,errors:s("number.infinity")};if(!y.isNumber(t))return{value:t,errors:s("number.base")};const o={value:t};if(e.convert){const r=i.$_getRule("precision");if(r){const a=Math.pow(10,r.args.limit);o.value=Math.round(o.value*a)/a}}return o.value===0&&(o.value=0),!i._flags.unsafe&&(t>Number.MAX_SAFE_INTEGER||t<Number.MIN_SAFE_INTEGER)&&(o.errors=s("number.unsafe")),o},rules:{compare:{method:!1,validate(t,n,i,s){let{limit:e}=i,{name:o,operator:r,args:a}=s;return y.compare(t,e,r)?t:n.error("number."+o,{limit:a.limit,value:t})},args:[{name:"limit",ref:!0,assert:y.isNumber,message:"must be a number"}]},greater:{method(t){return this.$_addRule({name:"greater",method:"compare",args:{limit:t},operator:">"})}},integer:{method(){return this.$_addRule("integer")},validate:(t,n)=>Math.trunc(t)-t==0?t:n.error("number.integer")},less:{method(t){return this.$_addRule({name:"less",method:"compare",args:{limit:t},operator:"<"})}},max:{method(t){return this.$_addRule({name:"max",method:"compare",args:{limit:t},operator:"<="})}},min:{method(t){return this.$_addRule({name:"min",method:"compare",args:{limit:t},operator:">="})}},multiple:{method(t){return this.$_addRule({name:"multiple",args:{base:t}})},validate(t,n,i,s){let{base:e}=i;return t*(1/e)%1==0?t:n.error("number.multiple",{multiple:s.args.base,value:t})},args:[{name:"base",ref:!0,assert:t=>typeof t=="number"&&isFinite(t)&&t>0,message:"must be a positive number"}],multi:!0},negative:{method(){return this.sign("negative")}},port:{method(){return this.$_addRule("port")},validate:(t,n)=>Number.isSafeInteger(t)&&t>=0&&t<=65535?t:n.error("number.port")},positive:{method(){return this.sign("positive")}},precision:{method(t){return l(Number.isSafeInteger(t),"limit must be an integer"),this.$_addRule({name:"precision",args:{limit:t}})},validate(t,n,i){let{limit:s}=i;const e=t.toString().match(f.precisionRx);return Math.max((e[1]?e[1].length:0)-(e[2]?parseInt(e[2],10):0),0)<=s?t:n.error("number.precision",{limit:s,value:t})},convert:!0},sign:{method(t){return l(["negative","positive"].includes(t),"Invalid sign",t),this.$_addRule({name:"sign",args:{sign:t}})},validate(t,n,i){let{sign:s}=i;return s==="negative"&&t<0||s==="positive"&&t>0?t:n.error(`number.${s}`)}},unsafe:{method(){let t=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return l(typeof t=="boolean","enabled must be a boolean"),this.$_setFlag("unsafe",t)}}},cast:{string:{from:t=>typeof t=="number",to:(t,n)=>t.toString()}},messages:{"number.base":"{{#label}} must be a number","number.greater":"{{#label}} must be greater than {{#limit}}","number.infinity":"{{#label}} cannot be infinity","number.integer":"{{#label}} must be an integer","number.less":"{{#label}} must be less than {{#limit}}","number.max":"{{#label}} must be less than or equal to {{#limit}}","number.min":"{{#label}} must be greater than or equal to {{#limit}}","number.multiple":"{{#label}} must be a multiple of {{#multiple}}","number.negative":"{{#label}} must be a negative number","number.port":"{{#label}} must be a valid port","number.positive":"{{#label}} must be a positive number","number.precision":"{{#label}} must have no more than {{#limit}} decimal places","number.unsafe":"{{#label}} must be a safe number"}}),f.extractSignificantDigits=function(t){return t.replace(f.exponentialPartRegex,"").replace(f.dotRegex,"").replace(f.trailingZerosRegex,"").replace(f.leadingSignAndZerosRegex,"")},f.normalizeDecimal=function(t){return(t=t.replace(/^\+/,"").replace(/\.0*$/,"").replace(/^(-?)\.([^\.]*)$/,"$10.$2").replace(/^(-?)0+([0-9])/,"$1$2")).includes(".")&&t.endsWith("0")&&(t=t.replace(/0+$/,"")),t==="-0"?"0":t}},8966:(A,$,v)=>{const l=v(7824);A.exports=l.extend({type:"object",cast:{map:{from:p=>p&&typeof p=="object",to:(p,y)=>new Map(Object.entries(p))}}})},7417:(A,$,v)=>{const l=v(375),p=v(5380),y=v(1745),f=v(9959),t=v(6064),n=v(9926),i=v(5752),s=v(8068),e=v(8160),o={tlds:n instanceof Set&&{tlds:{allow:n,deny:null}},base64Regex:{true:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/},false:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/}},dataUriRegex:/^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,hexRegex:/^[a-f0-9]+$/i,ipRegex:f.regex({cidr:"forbidden"}).regex,isoDurationRegex:/^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,guidBrackets:{"{":"}","[":"]","(":")","":""},guidVersions:{uuidv1:"1",uuidv2:"2",uuidv3:"3",uuidv4:"4",uuidv5:"5"},guidSeparators:new Set([void 0,!0,!1,"-",":"]),normalizationForms:["NFC","NFD","NFKC","NFKD"]};A.exports=s.extend({type:"string",flags:{insensitive:{default:!1},truncate:{default:!1}},terms:{replacements:{init:null}},coerce:{from:"string",method(r,a){let{schema:c,state:m,prefs:g}=a;const _=c.$_getRule("normalize");_&&(r=r.normalize(_.args.form));const b=c.$_getRule("case");b&&(r=b.args.direction==="upper"?r.toLocaleUpperCase():r.toLocaleLowerCase());const u=c.$_getRule("trim");if(u&&u.args.enabled&&(r=r.trim()),c.$_terms.replacements)for(const d of c.$_terms.replacements)r=r.replace(d.pattern,d.replacement);const h=c.$_getRule("hex");if(h&&h.args.options.byteAligned&&r.length%2!=0&&(r=`0${r}`),c.$_getRule("isoDate")){const d=o.isoDate(r);d&&(r=d)}if(c._flags.truncate){const d=c.$_getRule("max");if(d){let w=d.args.limit;if(e.isResolvable(w)&&(w=w.resolve(r,m,g),!e.limit(w)))return{value:r,errors:c.$_createError("any.ref",w,{ref:d.args.limit,arg:"limit",reason:"must be a positive integer"},m,g)};r=r.slice(0,w)}}return{value:r}}},validate(r,a){let{schema:c,error:m}=a;if(typeof r!="string")return{value:r,errors:m("string.base")};if(r===""){const g=c.$_getRule("min");return g&&g.args.limit===0?void 0:{value:r,errors:m("string.empty")}}},rules:{alphanum:{method(){return this.$_addRule("alphanum")},validate:(r,a)=>/^[a-zA-Z0-9]+$/.test(r)?r:a.error("string.alphanum")},base64:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return e.assertOptions(r,["paddingRequired","urlSafe"]),r={urlSafe:!1,paddingRequired:!0,...r},l(typeof r.paddingRequired=="boolean","paddingRequired must be boolean"),l(typeof r.urlSafe=="boolean","urlSafe must be boolean"),this.$_addRule({name:"base64",args:{options:r}})},validate(r,a,c){let{options:m}=c;return o.base64Regex[m.paddingRequired][m.urlSafe].test(r)?r:a.error("string.base64")}},case:{method(r){return l(["lower","upper"].includes(r),"Invalid case:",r),this.$_addRule({name:"case",args:{direction:r}})},validate(r,a,c){let{direction:m}=c;return m==="lower"&&r===r.toLocaleLowerCase()||m==="upper"&&r===r.toLocaleUpperCase()?r:a.error(`string.${m}case`)},convert:!0},creditCard:{method(){return this.$_addRule("creditCard")},validate(r,a){let c=r.length,m=0,g=1;for(;c--;){const _=r.charAt(c)*g;m+=_-9*(_>9),g^=3}return m>0&&m%10==0?r:a.error("string.creditCard")}},dataUri:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return e.assertOptions(r,["paddingRequired"]),r={paddingRequired:!0,...r},l(typeof r.paddingRequired=="boolean","paddingRequired must be boolean"),this.$_addRule({name:"dataUri",args:{options:r}})},validate(r,a,c){let{options:m}=c;const g=r.match(o.dataUriRegex);return g&&(!g[2]||g[2]!=="base64"||o.base64Regex[m.paddingRequired].false.test(g[3]))?r:a.error("string.dataUri")}},domain:{method(r){r&&e.assertOptions(r,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const a=o.addressOptions(r);return this.$_addRule({name:"domain",args:{options:r},address:a})},validate(r,a,c,m){let{address:g}=m;return p.isValid(r,g)?r:a.error("string.domain")}},email:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};e.assertOptions(r,["allowFullyQualified","allowUnicode","ignoreLength","maxDomainSegments","minDomainSegments","multiple","separator","tlds"]),l(r.multiple===void 0||typeof r.multiple=="boolean","multiple option must be an boolean");const a=o.addressOptions(r),c=new RegExp(`\\s*[${r.separator?t(r.separator):","}]\\s*`);return this.$_addRule({name:"email",args:{options:r},regex:c,address:a})},validate(r,a,c,m){let{options:g}=c,{regex:_,address:b}=m;const u=g.multiple?r.split(_):[r],h=[];for(const d of u)y.isValid(d,b)||h.push(d);return h.length?a.error("string.email",{value:r,invalids:h}):r}},guid:{alias:"uuid",method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};e.assertOptions(r,["version","separator"]);let a="";if(r.version){const g=[].concat(r.version);l(g.length>=1,"version must have at least 1 valid version specified");const _=new Set;for(let b=0;b<g.length;++b){const u=g[b];l(typeof u=="string","version at position "+b+" must be a string");const h=o.guidVersions[u.toLowerCase()];l(h,"version at position "+b+" must be one of "+Object.keys(o.guidVersions).join(", ")),l(!_.has(h),"version at position "+b+" must not be a duplicate"),a+=h,_.add(h)}}l(o.guidSeparators.has(r.separator),'separator must be one of true, false, "-", or ":"');const c=r.separator===void 0?"[:-]?":r.separator===!0?"[:-]":r.separator===!1?"[]?":`\\${r.separator}`,m=new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${c})[0-9A-F]{4}\\2?[${a||"0-9A-F"}][0-9A-F]{3}\\2?[${a?"89AB":"0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`,"i");return this.$_addRule({name:"guid",args:{options:r},regex:m})},validate(r,a,c,m){let{regex:g}=m;const _=g.exec(r);return _?o.guidBrackets[_[1]]!==_[_.length-1]?a.error("string.guid"):r:a.error("string.guid")}},hex:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return e.assertOptions(r,["byteAligned"]),r={byteAligned:!1,...r},l(typeof r.byteAligned=="boolean","byteAligned must be boolean"),this.$_addRule({name:"hex",args:{options:r}})},validate(r,a,c){let{options:m}=c;return o.hexRegex.test(r)?m.byteAligned&&r.length%2!=0?a.error("string.hexAlign"):r:a.error("string.hex")}},hostname:{method(){return this.$_addRule("hostname")},validate:(r,a)=>p.isValid(r,{minDomainSegments:1})||o.ipRegex.test(r)?r:a.error("string.hostname")},insensitive:{method(){return this.$_setFlag("insensitive",!0)}},ip:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};e.assertOptions(r,["cidr","version"]);const{cidr:a,versions:c,regex:m}=f.regex(r),g=r.version?c:void 0;return this.$_addRule({name:"ip",args:{options:{cidr:a,version:g}},regex:m})},validate(r,a,c,m){let{options:g}=c,{regex:_}=m;return _.test(r)?r:g.version?a.error("string.ipVersion",{value:r,cidr:g.cidr,version:g.version}):a.error("string.ip",{value:r,cidr:g.cidr})}},isoDate:{method(){return this.$_addRule("isoDate")},validate(r,a){let{error:c}=a;return o.isoDate(r)?r:c("string.isoDate")}},isoDuration:{method(){return this.$_addRule("isoDuration")},validate:(r,a)=>o.isoDurationRegex.test(r)?r:a.error("string.isoDuration")},length:{method(r,a){return o.length(this,"length",r,"=",a)},validate(r,a,c,m){let{limit:g,encoding:_}=c,{name:b,operator:u,args:h}=m;const d=!_&&r.length;return e.compare(d,g,u)?r:a.error("string."+b,{limit:h.limit,value:r,encoding:_})},args:[{name:"limit",ref:!0,assert:e.limit,message:"must be a positive integer"},"encoding"]},lowercase:{method(){return this.case("lower")}},max:{method(r,a){return o.length(this,"max",r,"<=",a)},args:["limit","encoding"]},min:{method(r,a){return o.length(this,"min",r,">=",a)},args:["limit","encoding"]},normalize:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"NFC";return l(o.normalizationForms.includes(r),"normalization form must be one of "+o.normalizationForms.join(", ")),this.$_addRule({name:"normalize",args:{form:r}})},validate(r,a,c){let{error:m}=a,{form:g}=c;return r===r.normalize(g)?r:m("string.normalize",{value:r,form:g})},convert:!0},pattern:{alias:"regex",method(r){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};l(r instanceof RegExp,"regex must be a RegExp"),l(!r.flags.includes("g")&&!r.flags.includes("y"),"regex should not use global or sticky mode"),typeof a=="string"&&(a={name:a}),e.assertOptions(a,["invert","name"]);const c=["string.pattern",a.invert?".invert":"",a.name?".name":".base"].join("");return this.$_addRule({name:"pattern",args:{regex:r,options:a},errorCode:c})},validate(r,a,c,m){let{regex:g,options:_}=c,{errorCode:b}=m;return g.test(r)^_.invert?r:a.error(b,{name:_.name,regex:g,value:r})},args:["regex","options"],multi:!0},replace:{method(r,a){typeof r=="string"&&(r=new RegExp(t(r),"g")),l(r instanceof RegExp,"pattern must be a RegExp"),l(typeof a=="string","replacement must be a String");const c=this.clone();return c.$_terms.replacements||(c.$_terms.replacements=[]),c.$_terms.replacements.push({pattern:r,replacement:a}),c}},token:{method(){return this.$_addRule("token")},validate:(r,a)=>/^\w+$/.test(r)?r:a.error("string.token")},trim:{method(){let r=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return l(typeof r=="boolean","enabled must be a boolean"),this.$_addRule({name:"trim",args:{enabled:r}})},validate(r,a,c){let{enabled:m}=c;return m&&r!==r.trim()?a.error("string.trim"):r},convert:!0},truncate:{method(){let r=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return l(typeof r=="boolean","enabled must be a boolean"),this.$_setFlag("truncate",r)}},uppercase:{method(){return this.case("upper")}},uri:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};e.assertOptions(r,["allowRelative","allowQuerySquareBrackets","domain","relativeOnly","scheme"]),r.domain&&e.assertOptions(r.domain,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const{regex:a,scheme:c}=i.regex(r),m=r.domain?o.addressOptions(r.domain):null;return this.$_addRule({name:"uri",args:{options:r},regex:a,domain:m,scheme:c})},validate(r,a,c,m){let{options:g}=c,{regex:_,domain:b,scheme:u}=m;if(["http:/","https:/"].includes(r))return a.error("string.uri");const h=_.exec(r);if(h){const d=h[1]||h[2];return!b||g.allowRelative&&!d||p.isValid(d,b)?r:a.error("string.domain",{value:d})}return g.relativeOnly?a.error("string.uriRelativeOnly"):g.scheme?a.error("string.uriCustomScheme",{scheme:u,value:r}):a.error("string.uri")}}},manifest:{build(r,a){if(a.replacements)for(const{pattern:c,replacement:m}of a.replacements)r=r.replace(c,m);return r}},messages:{"string.alphanum":"{{#label}} must only contain alpha-numeric characters","string.base":"{{#label}} must be a string","string.base64":"{{#label}} must be a valid base64 string","string.creditCard":"{{#label}} must be a credit card","string.dataUri":"{{#label}} must be a valid dataUri string","string.domain":"{{#label}} must contain a valid domain name","string.email":"{{#label}} must be a valid email","string.empty":"{{#label}} is not allowed to be empty","string.guid":"{{#label}} must be a valid GUID","string.hex":"{{#label}} must only contain hexadecimal characters","string.hexAlign":"{{#label}} hex decoded representation must be byte aligned","string.hostname":"{{#label}} must be a valid hostname","string.ip":"{{#label}} must be a valid ip address with a {{#cidr}} CIDR","string.ipVersion":"{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR","string.isoDate":"{{#label}} must be in iso format","string.isoDuration":"{{#label}} must be a valid ISO 8601 duration","string.length":"{{#label}} length must be {{#limit}} characters long","string.lowercase":"{{#label}} must only contain lowercase characters","string.max":"{{#label}} length must be less than or equal to {{#limit}} characters long","string.min":"{{#label}} length must be at least {{#limit}} characters long","string.normalize":"{{#label}} must be unicode normalized in the {{#form}} form","string.token":"{{#label}} must only contain alpha-numeric and underscore characters","string.pattern.base":"{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}","string.pattern.name":"{{#label}} with value {:[.]} fails to match the {{#name}} pattern","string.pattern.invert.base":"{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}","string.pattern.invert.name":"{{#label}} with value {:[.]} matches the inverted {{#name}} pattern","string.trim":"{{#label}} must not have leading or trailing whitespace","string.uri":"{{#label}} must be a valid uri","string.uriCustomScheme":"{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern","string.uriRelativeOnly":"{{#label}} must be a valid relative uri","string.uppercase":"{{#label}} must only contain uppercase characters"}}),o.addressOptions=function(r){if(!r||(l(r.minDomainSegments===void 0||Number.isSafeInteger(r.minDomainSegments)&&r.minDomainSegments>0,"minDomainSegments must be a positive integer"),l(r.maxDomainSegments===void 0||Number.isSafeInteger(r.maxDomainSegments)&&r.maxDomainSegments>0,"maxDomainSegments must be a positive integer"),r.tlds===!1))return r;if(r.tlds===!0||r.tlds===void 0)return l(o.tlds,"Built-in TLD list disabled"),Object.assign({},r,o.tlds);l(typeof r.tlds=="object","tlds must be true, false, or an object");const a=r.tlds.deny;if(a)return Array.isArray(a)&&(r=Object.assign({},r,{tlds:{deny:new Set(a)}})),l(r.tlds.deny instanceof Set,"tlds.deny must be an array, Set, or boolean"),l(!r.tlds.allow,"Cannot specify both tlds.allow and tlds.deny lists"),o.validateTlds(r.tlds.deny,"tlds.deny"),r;const c=r.tlds.allow;return c?c===!0?(l(o.tlds,"Built-in TLD list disabled"),Object.assign({},r,o.tlds)):(Array.isArray(c)&&(r=Object.assign({},r,{tlds:{allow:new Set(c)}})),l(r.tlds.allow instanceof Set,"tlds.allow must be an array, Set, or boolean"),o.validateTlds(r.tlds.allow,"tlds.allow"),r):r},o.validateTlds=function(r,a){for(const c of r)l(p.isValid(c,{minDomainSegments:1,maxDomainSegments:1}),`${a} must contain valid top level domain names`)},o.isoDate=function(r){if(!e.isIsoDate(r))return null;/.*T.*[+-]\d\d$/.test(r)&&(r+="00");const a=new Date(r);return isNaN(a.getTime())?null:a.toISOString()},o.length=function(r,a,c,m,g){return l(!g||!1,"Invalid encoding:",g),r.$_addRule({name:a,method:"length",args:{limit:c,encoding:g},operator:m})}},8826:(A,$,v)=>{const l=v(375),p=v(8068),y={};y.Map=class extends Map{slice(){return new y.Map(this)}},A.exports=p.extend({type:"symbol",terms:{map:{init:new y.Map}},coerce:{method(f,t){let{schema:n,error:i}=t;const s=n.$_terms.map.get(f);return s&&(f=s),n._flags.only&&typeof f!="symbol"?{value:f,errors:i("symbol.map",{map:n.$_terms.map})}:{value:f}}},validate(f,t){let{error:n}=t;if(typeof f!="symbol")return{value:f,errors:n("symbol.base")}},rules:{map:{method(f){f&&!f[Symbol.iterator]&&typeof f=="object"&&(f=Object.entries(f)),l(f&&f[Symbol.iterator],"Iterable must be an iterable or object");const t=this.clone(),n=[];for(const i of f){l(i&&i[Symbol.iterator],"Entry must be an iterable");const[s,e]=i;l(typeof s!="object"&&typeof s!="function"&&typeof s!="symbol","Key must not be of type object, function, or Symbol"),l(typeof e=="symbol","Value must be a Symbol"),t.$_terms.map.set(s,e),n.push(e)}return t.valid(...n)}}},manifest:{build:(f,t)=>(t.map&&(f=f.map(t.map)),f)},messages:{"symbol.base":"{{#label}} must be a symbol","symbol.map":"{{#label}} must be one of {{#map}}"}})},8863:(A,$,v)=>{const l=v(375),p=v(8571),y=v(738),f=v(9621),t=v(8160),n=v(6354),i=v(493),s={result:Symbol("result")};$.entry=function(e,o,r){let a=t.defaults;r&&(l(r.warnings===void 0,"Cannot override warnings preference in synchronous validation"),l(r.artifacts===void 0,"Cannot override artifacts preference in synchronous validation"),a=t.preferences(t.defaults,r));const c=s.entry(e,o,a);l(!c.mainstay.externals.length,"Schema with external rules must use validateAsync()");const m={value:c.value};return c.error&&(m.error=c.error),c.mainstay.warnings.length&&(m.warning=n.details(c.mainstay.warnings)),c.mainstay.debug&&(m.debug=c.mainstay.debug),c.mainstay.artifacts&&(m.artifacts=c.mainstay.artifacts),m},$.entryAsync=async function(e,o,r){let a=t.defaults;r&&(a=t.preferences(t.defaults,r));const c=s.entry(e,o,a),m=c.mainstay;if(c.error)throw m.debug&&(c.error.debug=m.debug),c.error;if(m.externals.length){let _=c.value;const b=[];for(const u of m.externals){const h=u.state.path,d=u.schema.type==="link"?m.links.get(u.schema):null;let w,S,R=_;const E=h.length?[_]:[],I=h.length?f(e,h):e;if(h.length){w=h[h.length-1];let D=_;for(const C of h.slice(0,-1))D=D[C],E.unshift(D);S=E[0],R=S[w]}try{const D=(M,L)=>(d||u.schema).$_createError(M,R,L,u.state,a),C=await u.method(R,{schema:u.schema,linked:d,state:u.state,prefs:r,original:I,error:D,errorsArray:s.errorsArray,warn:(M,L)=>m.warnings.push((d||u.schema).$_createError(M,R,L,u.state,a)),message:(M,L)=>(d||u.schema).$_createError("external",R,L,u.state,a,{messages:M})});if(C===void 0||C===R)continue;if(C instanceof n.Report){if(m.tracer.log(u.schema,u.state,"rule","external","error"),b.push(C),a.abortEarly)break;continue}if(Array.isArray(C)&&C[t.symbols.errors]){if(m.tracer.log(u.schema,u.state,"rule","external","error"),b.push(...C),a.abortEarly)break;continue}S?(m.tracer.value(u.state,"rule",R,C,"external"),S[w]=C):(m.tracer.value(u.state,"rule",_,C,"external"),_=C)}catch(D){throw a.errors.label&&(D.message+=` (${u.label})`),D}}if(c.value=_,b.length)throw c.error=n.process(b,e,a),m.debug&&(c.error.debug=m.debug),c.error}if(!a.warnings&&!a.debug&&!a.artifacts)return c.value;const g={value:c.value};return m.warnings.length&&(g.warning=n.details(m.warnings)),m.debug&&(g.debug=m.debug),m.artifacts&&(g.artifacts=m.artifacts),g},s.Mainstay=class{constructor(e,o,r){this.externals=[],this.warnings=[],this.tracer=e,this.debug=o,this.links=r,this.shadow=null,this.artifacts=null,this._snapshots=[]}snapshot(){this._snapshots.push({externals:this.externals.slice(),warnings:this.warnings.slice()})}restore(){const e=this._snapshots.pop();this.externals=e.externals,this.warnings=e.warnings}},s.entry=function(e,o,r){const{tracer:a,cleanup:c}=s.tracer(o,r),m=r.debug?[]:null,g=o._ids._schemaChain?new Map:null,_=new s.Mainstay(a,m,g),b=o._ids._schemaChain?[{schema:o}]:null,u=new i([],[],{mainstay:_,schemas:b}),h=$.validate(e,o,u,r);c&&o.$_root.untrace();const d=n.process(h.errors,e,r);return{value:h.value,error:d,mainstay:_}},s.tracer=function(e,o){return e.$_root._tracer?{tracer:e.$_root._tracer._register(e)}:o.debug?(l(e.$_root.trace,"Debug mode not supported"),{tracer:e.$_root.trace()._register(e),cleanup:!0}):{tracer:s.ignore}},$.validate=function(e,o,r,a){let c=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{};if(o.$_terms.whens&&(o=o._generate(e,r,a).schema),o._preferences&&(a=s.prefs(o,a)),o._cache&&a.cache){const d=o._cache.get(e);if(r.mainstay.tracer.debug(r,"validate","cached",!!d),d)return d}const m=(d,w,S)=>o.$_createError(d,e,w,S||r,a),g={original:e,prefs:a,schema:o,state:r,error:m,errorsArray:s.errorsArray,warn:(d,w,S)=>r.mainstay.warnings.push(m(d,w,S)),message:(d,w)=>o.$_createError("custom",e,w,r,a,{messages:d})};r.mainstay.tracer.entry(o,r);const _=o._definition;if(_.prepare&&e!==void 0&&a.convert){const d=_.prepare(e,g);if(d){if(r.mainstay.tracer.value(r,"prepare",e,d.value),d.errors)return s.finalize(d.value,[].concat(d.errors),g);e=d.value}}if(_.coerce&&e!==void 0&&a.convert&&(!_.coerce.from||_.coerce.from.includes(typeof e))){const d=_.coerce.method(e,g);if(d){if(r.mainstay.tracer.value(r,"coerced",e,d.value),d.errors)return s.finalize(d.value,[].concat(d.errors),g);e=d.value}}const b=o._flags.empty;b&&b.$_match(s.trim(e,o),r.nest(b),t.defaults)&&(r.mainstay.tracer.value(r,"empty",e,void 0),e=void 0);const u=c.presence||o._flags.presence||(o._flags._endedSwitch?null:a.presence);if(e===void 0){if(u==="forbidden")return s.finalize(e,null,g);if(u==="required")return s.finalize(e,[o.$_createError("any.required",e,null,r,a)],g);if(u==="optional"){if(o._flags.default!==t.symbols.deepDefault)return s.finalize(e,null,g);r.mainstay.tracer.value(r,"default",e,{}),e={}}}else if(u==="forbidden")return s.finalize(e,[o.$_createError("any.unknown",e,null,r,a)],g);const h=[];if(o._valids){const d=o._valids.get(e,r,a,o._flags.insensitive);if(d)return a.convert&&(r.mainstay.tracer.value(r,"valids",e,d.value),e=d.value),r.mainstay.tracer.filter(o,r,"valid",d),s.finalize(e,null,g);if(o._flags.only){const w=o.$_createError("any.only",e,{valids:o._valids.values({display:!0})},r,a);if(a.abortEarly)return s.finalize(e,[w],g);h.push(w)}}if(o._invalids){const d=o._invalids.get(e,r,a,o._flags.insensitive);if(d){r.mainstay.tracer.filter(o,r,"invalid",d);const w=o.$_createError("any.invalid",e,{invalids:o._invalids.values({display:!0})},r,a);if(a.abortEarly)return s.finalize(e,[w],g);h.push(w)}}if(_.validate){const d=_.validate(e,g);if(d&&(r.mainstay.tracer.value(r,"base",e,d.value),e=d.value,d.errors)){if(!Array.isArray(d.errors))return h.push(d.errors),s.finalize(e,h,g);if(d.errors.length)return h.push(...d.errors),s.finalize(e,h,g)}}return o._rules.length?s.rules(e,h,g):s.finalize(e,h,g)},s.rules=function(e,o,r){const{schema:a,state:c,prefs:m}=r;for(const g of a._rules){const _=a._definition.rules[g.method];if(_.convert&&m.convert){c.mainstay.tracer.log(a,c,"rule",g.name,"full");continue}let b,u=g.args;if(g._resolve.length){u=Object.assign({},u);for(const d of g._resolve){const w=_.argsByName.get(d),S=u[d].resolve(e,c,m),R=w.normalize?w.normalize(S):S,E=t.validateArg(R,null,w);if(E){b=a.$_createError("any.ref",S,{arg:d,ref:u[d],reason:E},c,m);break}u[d]=R}}b=b||_.validate(e,r,u,g);const h=s.rule(b,g);if(h.errors){if(c.mainstay.tracer.log(a,c,"rule",g.name,"error"),g.warn){c.mainstay.warnings.push(...h.errors);continue}if(m.abortEarly)return s.finalize(e,h.errors,r);o.push(...h.errors)}else c.mainstay.tracer.log(a,c,"rule",g.name,"pass"),c.mainstay.tracer.value(c,"rule",e,h.value,g.name),e=h.value}return s.finalize(e,o,r)},s.rule=function(e,o){return e instanceof n.Report?(s.error(e,o),{errors:[e],value:null}):Array.isArray(e)&&e[t.symbols.errors]?(e.forEach(r=>s.error(r,o)),{errors:e,value:null}):{errors:null,value:e}},s.error=function(e,o){return o.message&&e._setTemplate(o.message),e},s.finalize=function(e,o,r){o=o||[];const{schema:a,state:c,prefs:m}=r;if(o.length){const _=s.default("failover",void 0,o,r);_!==void 0&&(c.mainstay.tracer.value(c,"failover",e,_),e=_,o=[])}if(o.length&&a._flags.error)if(typeof a._flags.error=="function"){o=a._flags.error(o),Array.isArray(o)||(o=[o]);for(const _ of o)l(_ instanceof Error||_ instanceof n.Report,"error() must return an Error object")}else o=[a._flags.error];if(e===void 0){const _=s.default("default",e,o,r);c.mainstay.tracer.value(c,"default",e,_),e=_}if(a._flags.cast&&e!==void 0){const _=a._definition.cast[a._flags.cast];if(_.from(e)){const b=_.to(e,r);c.mainstay.tracer.value(c,"cast",e,b,a._flags.cast),e=b}}if(a.$_terms.externals&&m.externals&&m._externals!==!1)for(const{method:_}of a.$_terms.externals)c.mainstay.externals.push({method:_,schema:a,state:c,label:n.label(a._flags,c,m)});const g={value:e,errors:o.length?o:null};return a._flags.result&&(g.value=a._flags.result==="strip"?void 0:r.original,c.mainstay.tracer.value(c,a._flags.result,e,g.value),c.shadow(e,a._flags.result)),a._cache&&m.cache!==!1&&!a._refs.length&&a._cache.set(r.original,g),e===void 0||g.errors||a._flags.artifact===void 0||(c.mainstay.artifacts=c.mainstay.artifacts||new Map,c.mainstay.artifacts.has(a._flags.artifact)||c.mainstay.artifacts.set(a._flags.artifact,[]),c.mainstay.artifacts.get(a._flags.artifact).push(c.path)),g},s.prefs=function(e,o){const r=o===t.defaults;return r&&e._preferences[t.symbols.prefs]?e._preferences[t.symbols.prefs]:(o=t.preferences(o,e._preferences),r&&(e._preferences[t.symbols.prefs]=o),o)},s.default=function(e,o,r,a){const{schema:c,state:m,prefs:g}=a,_=c._flags[e];if(g.noDefaults||_===void 0)return o;if(m.mainstay.tracer.log(c,m,"rule",e,"full"),!_)return _;if(typeof _=="function"){const b=_.length?[p(m.ancestors[0]),a]:[];try{return _(...b)}catch(u){return void r.push(c.$_createError(`any.${e}`,null,{error:u},m,g))}}return typeof _!="object"?_:_[t.symbols.literal]?_.literal:t.isResolvable(_)?_.resolve(o,m,g):p(_)},s.trim=function(e,o){if(typeof e!="string")return e;const r=o.$_getRule("trim");return r&&r.args.enabled?e.trim():e},s.ignore={active:!1,debug:y,entry:y,filter:y,log:y,resolve:y,value:y},s.errorsArray=function(){const e=[];return e[t.symbols.errors]=!0,e}},2036:(A,$,v)=>{const l=v(375),p=v(9474),y=v(8160),f={};A.exports=f.Values=class{constructor(t,n){this._values=new Set(t),this._refs=new Set(n),this._lowercase=f.lowercases(t),this._override=!1}get length(){return this._values.size+this._refs.size}add(t,n){y.isResolvable(t)?this._refs.has(t)||(this._refs.add(t),n&&n.register(t)):this.has(t,null,null,!1)||(this._values.add(t),typeof t=="string"&&this._lowercase.set(t.toLowerCase(),t))}static merge(t,n,i){if(t=t||new f.Values,n){if(n._override)return n.clone();for(const s of[...n._values,...n._refs])t.add(s)}if(i)for(const s of[...i._values,...i._refs])t.remove(s);return t.length?t:null}remove(t){y.isResolvable(t)?this._refs.delete(t):(this._values.delete(t),typeof t=="string"&&this._lowercase.delete(t.toLowerCase()))}has(t,n,i,s){return!!this.get(t,n,i,s)}get(t,n,i,s){if(!this.length)return!1;if(this._values.has(t))return{value:t};if(typeof t=="string"&&t&&s){const e=this._lowercase.get(t.toLowerCase());if(e)return{value:e}}if(!this._refs.size&&typeof t!="object")return!1;if(typeof t=="object"){for(const e of this._values)if(p(e,t))return{value:e}}if(n)for(const e of this._refs){const o=e.resolve(t,n,i,null,{in:!0});if(o===void 0)continue;const r=e.in&&typeof o=="object"?Array.isArray(o)?o:Object.keys(o):[o];for(const a of r)if(typeof a==typeof t){if(s&&t&&typeof t=="string"){if(a.toLowerCase()===t.toLowerCase())return{value:a,ref:e}}else if(p(a,t))return{value:a,ref:e}}}return!1}override(){this._override=!0}values(t){if(t&&t.display){const n=[];for(const i of[...this._values,...this._refs])i!==void 0&&n.push(i);return n}return Array.from([...this._values,...this._refs])}clone(){const t=new f.Values(this._values,this._refs);return t._override=this._override,t}concat(t){l(!t._override,"Cannot concat override set of values");const n=new f.Values([...this._values,...t._values],[...this._refs,...t._refs]);return n._override=this._override,n}describe(){const t=[];this._override&&t.push({override:!0});for(const n of this._values.values())t.push(n&&typeof n=="object"?{value:n}:n);for(const n of this._refs.values())t.push(n.describe());return t}},f.Values.prototype[y.symbols.values]=!0,f.Values.prototype.slice=f.Values.prototype.clone,f.lowercases=function(t){const n=new Map;if(t)for(const i of t)typeof i=="string"&&n.set(i.toLowerCase(),i);return n}},978:(A,$,v)=>{const l=v(375),p=v(8571),y=v(1687),f=v(9621),t={};A.exports=function(n,i){let s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(l(n&&typeof n=="object","Invalid defaults value: must be an object"),l(!i||i===!0||typeof i=="object","Invalid source value: must be true, falsy or an object"),l(typeof s=="object","Invalid options: must be an object"),!i)return null;if(s.shallow)return t.applyToDefaultsWithShallow(n,i,s);const e=p(n);if(i===!0)return e;const o=s.nullOverride!==void 0&&s.nullOverride;return y(e,i,{nullOverride:o,mergeArrays:!1})},t.applyToDefaultsWithShallow=function(n,i,s){const e=s.shallow;l(Array.isArray(e),"Invalid keys");const o=new Map,r=i===!0?null:new Set;for(let m of e){m=Array.isArray(m)?m:m.split(".");const g=f(n,m);g&&typeof g=="object"?o.set(g,r&&f(i,m)||g):r&&r.add(m)}const a=p(n,{},o);if(!r)return a;for(const m of r)t.reachCopy(a,i,m);const c=s.nullOverride!==void 0&&s.nullOverride;return y(a,i,{nullOverride:c,mergeArrays:!1})},t.reachCopy=function(n,i,s){for(const r of s){if(!(r in i))return;const a=i[r];if(typeof a!="object"||a===null)return;i=a}const e=i;let o=n;for(let r=0;r<s.length-1;++r){const a=s[r];typeof o[a]!="object"&&(o[a]={}),o=o[a]}o[s[s.length-1]]=e}},375:(A,$,v)=>{const l=v(7916);A.exports=function(p){if(!p){for(var y=arguments.length,f=new Array(y>1?y-1:0),t=1;t<y;t++)f[t-1]=arguments[t];throw f.length===1&&f[0]instanceof Error?f[0]:new l(f)}}},8571:(A,$,v)=>{const l=v(9621),p=v(4277),y=v(7043),f={needsProtoHack:new Set([p.set,p.map,p.weakSet,p.weakMap])};A.exports=f.clone=function(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:null;if(typeof t!="object"||t===null)return t;let s=f.clone,e=i;if(n.shallow){if(n.shallow!==!0)return f.cloneWithShallow(t,n);s=c=>c}else if(e){const c=e.get(t);if(c)return c}else e=new Map;const o=p.getInternalProto(t);if(o===p.buffer)return!1;if(o===p.date)return new Date(t.getTime());if(o===p.regex)return new RegExp(t);const r=f.base(t,o,n);if(r===t)return t;if(e&&e.set(t,r),o===p.set)for(const c of t)r.add(s(c,n,e));else if(o===p.map)for(const[c,m]of t)r.set(c,s(m,n,e));const a=y.keys(t,n);for(const c of a){if(c==="__proto__")continue;if(o===p.array&&c==="length"){r.length=t.length;continue}const m=Object.getOwnPropertyDescriptor(t,c);m?m.get||m.set?Object.defineProperty(r,c,m):m.enumerable?r[c]=s(t[c],n,e):Object.defineProperty(r,c,{enumerable:!1,writable:!0,configurable:!0,value:s(t[c],n,e)}):Object.defineProperty(r,c,{enumerable:!0,writable:!0,configurable:!0,value:s(t[c],n,e)})}return r},f.cloneWithShallow=function(t,n){const i=n.shallow;(n=Object.assign({},n)).shallow=!1;const s=new Map;for(const e of i){const o=l(t,e);typeof o!="object"&&typeof o!="function"||s.set(o,o)}return f.clone(t,n,s)},f.base=function(t,n,i){if(i.prototype===!1)return f.needsProtoHack.has(n)?new n.constructor:n===p.array?[]:{};const s=Object.getPrototypeOf(t);if(s&&s.isImmutable)return t;if(n===p.array){const e=[];return s!==n&&Object.setPrototypeOf(e,s),e}if(f.needsProtoHack.has(n)){const e=new s.constructor;return s!==n&&Object.setPrototypeOf(e,s),e}return Object.create(s)}},9474:(A,$,v)=>{const l=v(4277),p={mismatched:null};A.exports=function(y,f,t){return t=Object.assign({prototype:!0},t),!!p.isDeepEqual(y,f,t,[])},p.isDeepEqual=function(y,f,t,n){if(y===f)return y!==0||1/y==1/f;const i=typeof y;if(i!==typeof f||y===null||f===null)return!1;if(i==="function"){if(!t.deepFunction||y.toString()!==f.toString())return!1}else if(i!=="object")return y!=y&&f!=f;const s=p.getSharedType(y,f,!!t.prototype);switch(s){case l.buffer:return!1;case l.promise:return y===f;case l.regex:return y.toString()===f.toString();case p.mismatched:return!1}for(let e=n.length-1;e>=0;--e)if(n[e].isSame(y,f))return!0;n.push(new p.SeenEntry(y,f));try{return!!p.isDeepEqualObj(s,y,f,t,n)}finally{n.pop()}},p.getSharedType=function(y,f,t){if(t)return Object.getPrototypeOf(y)!==Object.getPrototypeOf(f)?p.mismatched:l.getInternalProto(y);const n=l.getInternalProto(y);return n!==l.getInternalProto(f)?p.mismatched:n},p.valueOf=function(y){const f=y.valueOf;if(f===void 0)return y;try{return f.call(y)}catch(t){return t}},p.hasOwnEnumerableProperty=function(y,f){return Object.prototype.propertyIsEnumerable.call(y,f)},p.isSetSimpleEqual=function(y,f){for(const t of Set.prototype.values.call(y))if(!Set.prototype.has.call(f,t))return!1;return!0},p.isDeepEqualObj=function(y,f,t,n,i){const{isDeepEqual:s,valueOf:e,hasOwnEnumerableProperty:o}=p,{keys:r,getOwnPropertySymbols:a}=Object;if(y===l.array){if(!n.part){if(f.length!==t.length)return!1;for(let b=0;b<f.length;++b)if(!s(f[b],t[b],n,i))return!1;return!0}for(const b of f)for(const u of t)if(s(b,u,n,i))return!0}else if(y===l.set){if(f.size!==t.size)return!1;if(!p.isSetSimpleEqual(f,t)){const b=new Set(Set.prototype.values.call(t));for(const u of Set.prototype.values.call(f)){if(b.delete(u))continue;let h=!1;for(const d of b)if(s(u,d,n,i)){b.delete(d),h=!0;break}if(!h)return!1}}}else if(y===l.map){if(f.size!==t.size)return!1;for(const[b,u]of Map.prototype.entries.call(f))if(u===void 0&&!Map.prototype.has.call(t,b)||!s(u,Map.prototype.get.call(t,b),n,i))return!1}else if(y===l.error&&(f.name!==t.name||f.message!==t.message))return!1;const c=e(f),m=e(t);if((f!==c||t!==m)&&!s(c,m,n,i))return!1;const g=r(f);if(!n.part&&g.length!==r(t).length&&!n.skip)return!1;let _=0;for(const b of g)if(n.skip&&n.skip.includes(b))t[b]===void 0&&++_;else if(!o(t,b)||!s(f[b],t[b],n,i))return!1;if(!n.part&&g.length-_!==r(t).length)return!1;if(n.symbols!==!1){const b=a(f),u=new Set(a(t));for(const h of b){if(!n.skip||!n.skip.includes(h)){if(o(f,h)){if(!o(t,h)||!s(f[h],t[h],n,i))return!1}else if(o(t,h))return!1}u.delete(h)}for(const h of u)if(o(t,h))return!1}return!0},p.SeenEntry=class{constructor(y,f){this.obj=y,this.ref=f}isSame(y,f){return this.obj===y&&this.ref===f}}},7916:(A,$,v)=>{const l=v(8761);A.exports=class extends Error{constructor(p){super(p.filter(y=>y!=="").map(y=>typeof y=="string"?y:y instanceof Error?y.message:l(y)).join(" ")||"Unknown error"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$.assert)}}},5277:A=>{const $={};A.exports=function(v){if(!v)return"";let l="";for(let p=0;p<v.length;++p){const y=v.charCodeAt(p);$.isSafe(y)?l+=v[p]:l+=$.escapeHtmlChar(y)}return l},$.escapeHtmlChar=function(v){return $.namedHtml.get(v)||(v>=256?"&#"+v+";":`&#x${v.toString(16).padStart(2,"0")};`)},$.isSafe=function(v){return $.safeCharCodes.has(v)},$.namedHtml=new Map([[38,"&amp;"],[60,"&lt;"],[62,"&gt;"],[34,"&quot;"],[160,"&nbsp;"],[162,"&cent;"],[163,"&pound;"],[164,"&curren;"],[169,"&copy;"],[174,"&reg;"]]),$.safeCharCodes=function(){const v=new Set;for(let l=32;l<123;++l)(l>=97||l>=65&&l<=90||l>=48&&l<=57||l===32||l===46||l===44||l===45||l===58||l===95)&&v.add(l);return v}()},6064:A=>{A.exports=function($){return $.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,"\\$&")}},738:A=>{A.exports=function(){}},1687:(A,$,v)=>{const l=v(375),p=v(8571),y=v(7043),f={};A.exports=f.merge=function(t,n,i){if(l(t&&typeof t=="object","Invalid target value: must be an object"),l(n==null||typeof n=="object","Invalid source value: must be null, undefined, or an object"),!n)return t;if(i=Object.assign({nullOverride:!0,mergeArrays:!0},i),Array.isArray(n)){l(Array.isArray(t),"Cannot merge array onto an object"),i.mergeArrays||(t.length=0);for(let e=0;e<n.length;++e)t.push(p(n[e],{symbols:i.symbols}));return t}const s=y.keys(n,i);for(let e=0;e<s.length;++e){const o=s[e];if(o==="__proto__"||!Object.prototype.propertyIsEnumerable.call(n,o))continue;const r=n[o];if(r&&typeof r=="object"){if(t[o]===r)continue;!t[o]||typeof t[o]!="object"||Array.isArray(t[o])!==Array.isArray(r)||r instanceof Date||r instanceof RegExp?t[o]=p(r,{symbols:i.symbols}):f.merge(t[o],r,i)}else(r!=null||i.nullOverride)&&(t[o]=r)}return t}},9621:(A,$,v)=>{const l=v(375),p={};A.exports=function(y,f,t){if(f===!1||f==null)return y;typeof(t=t||{})=="string"&&(t={separator:t});const n=Array.isArray(f);l(!n||!t.separator,"Separator option is not valid for array-based chain");const i=n?f:f.split(t.separator||".");let s=y;for(let e=0;e<i.length;++e){let o=i[e];const r=t.iterables&&p.iterables(s);if(Array.isArray(s)||r==="set"){const a=Number(o);Number.isInteger(a)&&(o=a<0?s.length+a:a)}if(!s||typeof s=="function"&&t.functions===!1||!r&&s[o]===void 0){l(!t.strict||e+1===i.length,"Missing segment",o,"in reach path ",f),l(typeof s=="object"||t.functions===!0||typeof s!="function","Invalid segment",o,"in reach path ",f),s=t.default;break}s=r?r==="set"?[...s][o]:s.get(o):s[o]}return s},p.iterables=function(y){return y instanceof Set?"set":y instanceof Map?"map":void 0}},8761:A=>{A.exports=function(){try{return JSON.stringify(...arguments)}catch($){return"[Cannot display object: "+$.message+"]"}}},4277:(A,$)=>{const v={};$=A.exports={array:Array.prototype,buffer:!1,date:Date.prototype,error:Error.prototype,generic:Object.prototype,map:Map.prototype,promise:Promise.prototype,regex:RegExp.prototype,set:Set.prototype,weakMap:WeakMap.prototype,weakSet:WeakSet.prototype},v.typeMap=new Map([["[object Error]",$.error],["[object Map]",$.map],["[object Promise]",$.promise],["[object Set]",$.set],["[object WeakMap]",$.weakMap],["[object WeakSet]",$.weakSet]]),$.getInternalProto=function(l){if(Array.isArray(l))return $.array;if(l instanceof Date)return $.date;if(l instanceof RegExp)return $.regex;if(l instanceof Error)return $.error;const p=Object.prototype.toString.call(l);return v.typeMap.get(p)||$.generic}},7043:(A,$)=>{$.keys=function(v){return(arguments.length>1&&arguments[1]!==void 0?arguments[1]:{}).symbols!==!1?Reflect.ownKeys(v):Object.getOwnPropertyNames(v)}},3652:(A,$,v)=>{const l=v(375),p={};$.Sorter=class{constructor(){this._items=[],this.nodes=[]}add(y,f){const t=[].concat((f=f||{}).before||[]),n=[].concat(f.after||[]),i=f.group||"?",s=f.sort||0;l(!t.includes(i),`Item cannot come before itself: ${i}`),l(!t.includes("?"),"Item cannot come before unassociated items"),l(!n.includes(i),`Item cannot come after itself: ${i}`),l(!n.includes("?"),"Item cannot come after unassociated items"),Array.isArray(y)||(y=[y]);for(const e of y){const o={seq:this._items.length,sort:s,before:t,after:n,group:i,node:e};this._items.push(o)}if(!f.manual){const e=this._sort();l(e,"item",i!=="?"?`added into group ${i}`:"","created a dependencies error")}return this.nodes}merge(y){Array.isArray(y)||(y=[y]);for(const t of y)if(t)for(const n of t._items)this._items.push(Object.assign({},n));this._items.sort(p.mergeSort);for(let t=0;t<this._items.length;++t)this._items[t].seq=t;const f=this._sort();return l(f,"merge created a dependencies error"),this.nodes}sort(){const y=this._sort();return l(y,"sort created a dependencies error"),this.nodes}_sort(){const y={},f=Object.create(null),t=Object.create(null);for(const o of this._items){const r=o.seq,a=o.group;t[a]=t[a]||[],t[a].push(r),y[r]=o.before;for(const c of o.after)f[c]=f[c]||[],f[c].push(r)}for(const o in y){const r=[];for(const a in y[o]){const c=y[o][a];t[c]=t[c]||[],r.push(...t[c])}y[o]=r}for(const o in f)if(t[o])for(const r of t[o])y[r].push(...f[o]);const n={};for(const o in y){const r=y[o];for(const a of r)n[a]=n[a]||[],n[a].push(o)}const i={},s=[];for(let o=0;o<this._items.length;++o){let r=o;if(n[o]){r=null;for(let a=0;a<this._items.length;++a){if(i[a]===!0)continue;n[a]||(n[a]=[]);const c=n[a].length;let m=0;for(let g=0;g<c;++g)i[n[a][g]]&&++m;if(m===c){r=a;break}}}r!==null&&(i[r]=!0,s.push(r))}if(s.length!==this._items.length)return!1;const e={};for(const o of this._items)e[o.seq]=o;this._items=[],this.nodes=[];for(const o of s){const r=e[o];this.nodes.push(r.node),this._items.push(r)}return!0}},p.mergeSort=(y,f)=>y.sort===f.sort?0:y.sort<f.sort?-1:1},5380:(A,$,v)=>{const l=v(443),p=v(2178),y={minDomainSegments:2,nonAsciiRx:/[^\x00-\x7f]/,domainControlRx:/[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,tldSegmentRx:/^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,domainSegmentRx:/^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,URL:l.URL||URL};$.analyze=function(f){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!f)return p.code("DOMAIN_NON_EMPTY_STRING");if(typeof f!="string")throw new Error("Invalid input: domain must be a string");if(f.length>256)return p.code("DOMAIN_TOO_LONG");if(y.nonAsciiRx.test(f)){if(t.allowUnicode===!1)return p.code("DOMAIN_INVALID_UNICODE_CHARS");f=f.normalize("NFC")}if(y.domainControlRx.test(f))return p.code("DOMAIN_INVALID_CHARS");f=y.punycode(f),t.allowFullyQualified&&f[f.length-1]==="."&&(f=f.slice(0,-1));const n=t.minDomainSegments||y.minDomainSegments,i=f.split(".");if(i.length<n)return p.code("DOMAIN_SEGMENTS_COUNT");if(t.maxDomainSegments&&i.length>t.maxDomainSegments)return p.code("DOMAIN_SEGMENTS_COUNT_MAX");const s=t.tlds;if(s){const e=i[i.length-1].toLowerCase();if(s.deny&&s.deny.has(e)||s.allow&&!s.allow.has(e))return p.code("DOMAIN_FORBIDDEN_TLDS")}for(let e=0;e<i.length;++e){const o=i[e];if(!o.length)return p.code("DOMAIN_EMPTY_SEGMENT");if(o.length>63)return p.code("DOMAIN_LONG_SEGMENT");if(e<i.length-1){if(!y.domainSegmentRx.test(o))return p.code("DOMAIN_INVALID_CHARS")}else if(!y.tldSegmentRx.test(o))return p.code("DOMAIN_INVALID_TLDS_CHARS")}return null},$.isValid=function(f,t){return!$.analyze(f,t)},y.punycode=function(f){f.includes("%")&&(f=f.replace(/%/g,"%25"));try{return new y.URL(`http://${f}`).host}catch{return f}}},1745:(A,$,v)=>{const l=v(9848),p=v(5380),y=v(2178),f={nonAsciiRx:/[^\x00-\x7f]/,encoder:new(l.TextEncoder||TextEncoder)};$.analyze=function(t,n){return f.email(t,n)},$.isValid=function(t,n){return!f.email(t,n)},f.email=function(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(typeof t!="string")throw new Error("Invalid input: email must be a string");if(!t)return y.code("EMPTY_STRING");const i=!f.nonAsciiRx.test(t);if(!i){if(n.allowUnicode===!1)return y.code("FORBIDDEN_UNICODE");t=t.normalize("NFC")}const s=t.split("@");if(s.length!==2)return s.length>2?y.code("MULTIPLE_AT_CHAR"):y.code("MISSING_AT_CHAR");const[e,o]=s;if(!e)return y.code("EMPTY_LOCAL");if(!n.ignoreLength){if(t.length>254)return y.code("ADDRESS_TOO_LONG");if(f.encoder.encode(e).length>64)return y.code("LOCAL_TOO_LONG")}return f.local(e,i)||p.analyze(o,n)},f.local=function(t,n){const i=t.split(".");for(const s of i){if(!s.length)return y.code("EMPTY_LOCAL_SEGMENT");if(n){if(!f.atextRx.test(s))return y.code("INVALID_LOCAL_CHARS")}else for(const e of s){if(f.atextRx.test(e))continue;const o=f.binary(e);if(!f.atomRx.test(o))return y.code("INVALID_LOCAL_CHARS")}}},f.binary=function(t){return Array.from(f.encoder.encode(t)).map(n=>String.fromCharCode(n)).join("")},f.atextRx=/^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/,f.atomRx=new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])","(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})","(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"))},2178:(A,$)=>{$.codes={EMPTY_STRING:"Address must be a non-empty string",FORBIDDEN_UNICODE:"Address contains forbidden Unicode characters",MULTIPLE_AT_CHAR:"Address cannot contain more than one @ character",MISSING_AT_CHAR:"Address must contain one @ character",EMPTY_LOCAL:"Address local part cannot be empty",ADDRESS_TOO_LONG:"Address too long",LOCAL_TOO_LONG:"Address local part too long",EMPTY_LOCAL_SEGMENT:"Address local part contains empty dot-separated segment",INVALID_LOCAL_CHARS:"Address local part contains invalid character",DOMAIN_NON_EMPTY_STRING:"Domain must be a non-empty string",DOMAIN_TOO_LONG:"Domain too long",DOMAIN_INVALID_UNICODE_CHARS:"Domain contains forbidden Unicode characters",DOMAIN_INVALID_CHARS:"Domain contains invalid character",DOMAIN_INVALID_TLDS_CHARS:"Domain contains invalid tld character",DOMAIN_SEGMENTS_COUNT:"Domain lacks the minimum required number of segments",DOMAIN_SEGMENTS_COUNT_MAX:"Domain contains too many segments",DOMAIN_FORBIDDEN_TLDS:"Domain uses forbidden TLD",DOMAIN_EMPTY_SEGMENT:"Domain contains empty dot-separated segment",DOMAIN_LONG_SEGMENT:"Domain contains dot-separated segment that is too long"},$.code=function(v){return{code:v,error:$.codes[v]}}},9959:(A,$,v)=>{const l=v(375),p=v(5752);$.regex=function(){let y=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};l(y.cidr===void 0||typeof y.cidr=="string","options.cidr must be a string");const f=y.cidr?y.cidr.toLowerCase():"optional";l(["required","optional","forbidden"].includes(f),"options.cidr must be one of required, optional, forbidden"),l(y.version===void 0||typeof y.version=="string"||Array.isArray(y.version),"options.version must be a string or an array of string");let t=y.version||["ipv4","ipv6","ipvfuture"];Array.isArray(t)||(t=[t]),l(t.length>=1,"options.version must have at least 1 version specified");for(let s=0;s<t.length;++s)l(typeof t[s]=="string","options.version must only contain strings"),t[s]=t[s].toLowerCase(),l(["ipv4","ipv6","ipvfuture"].includes(t[s]),"options.version contains unknown version "+t[s]+" - must be one of ipv4, ipv6, ipvfuture");t=Array.from(new Set(t));const n=`(?:${t.map(s=>{if(f==="forbidden")return p.ip[s];const e=`\\/${s==="ipv4"?p.ip.v4Cidr:p.ip.v6Cidr}`;return f==="required"?`${p.ip[s]}${e}`:`${p.ip[s]}(?:${e})?`}).join("|")})`,i=new RegExp(`^${n}$`);return{cidr:f,versions:t,regex:i,raw:n}}},5752:(A,$,v)=>{const l=v(375),p=v(6064),y={generate:function(){const f={},t="\\dA-Fa-f",n="["+t+"]",i="\\w-\\.~",s="!\\$&'\\(\\)\\*\\+,;=",e="%"+t,o=i+e+s+":@",r="["+o+"]",a="(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";f.ipv4address="(?:"+a+"\\.){3}"+a;const c=n+"{1,4}",m="(?:"+c+":"+c+"|"+f.ipv4address+")",g="(?:"+c+":){6}"+m,_="::(?:"+c+":){5}"+m,b="(?:"+c+")?::(?:"+c+":){4}"+m,u="(?:(?:"+c+":){0,1}"+c+")?::(?:"+c+":){3}"+m,h="(?:(?:"+c+":){0,2}"+c+")?::(?:"+c+":){2}"+m,d="(?:(?:"+c+":){0,3}"+c+")?::"+c+":"+m,w="(?:(?:"+c+":){0,4}"+c+")?::"+m,S="(?:(?:"+c+":){0,5}"+c+")?::"+c,R="(?:(?:"+c+":){0,6}"+c+")?::";f.ipv4Cidr="(?:\\d|[1-2]\\d|3[0-2])",f.ipv6Cidr="(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])",f.ipv6address="(?:"+g+"|"+_+"|"+b+"|"+u+"|"+h+"|"+d+"|"+w+"|"+S+"|"+R+")",f.ipvFuture="v"+n+"+\\.["+i+s+":]+",f.scheme="[a-zA-Z][a-zA-Z\\d+-\\.]*",f.schemeRegex=new RegExp(f.scheme);const E="["+i+e+s+":]*",I="["+i+e+s+"]{1,255}",D="(?:\\[(?:"+f.ipv6address+"|"+f.ipvFuture+")\\]|"+f.ipv4address+"|"+I+")",C="(?:"+E+"@)?"+D+"(?::\\d*)?",M="(?:"+E+"@)?("+D+")(?::\\d*)?",L=r+"*",U=r+"+",T="(?:\\/"+L+")*",N="\\/(?:"+U+T+")?",P=U+T,q="["+i+e+s+"@]+"+T,W="(?:\\/\\/\\/"+L+T+")";return f.hierPart="(?:(?:\\/\\/"+C+T+")|"+N+"|"+P+"|"+W+")",f.hierPartCapture="(?:(?:\\/\\/"+M+T+")|"+N+"|"+P+")",f.relativeRef="(?:(?:\\/\\/"+C+T+")|"+N+"|"+q+"|)",f.relativeRefCapture="(?:(?:\\/\\/"+M+T+")|"+N+"|"+q+"|)",f.query="["+o+"\\/\\?]*(?=#|$)",f.queryWithSquareBrackets="["+o+"\\[\\]\\/\\?]*(?=#|$)",f.fragment="["+o+"\\/\\?]*",f}};y.rfc3986=y.generate(),$.ip={v4Cidr:y.rfc3986.ipv4Cidr,v6Cidr:y.rfc3986.ipv6Cidr,ipv4:y.rfc3986.ipv4address,ipv6:y.rfc3986.ipv6address,ipvfuture:y.rfc3986.ipvFuture},y.createRegex=function(f){const t=y.rfc3986,n="(?:\\?"+(f.allowQuerySquareBrackets?t.queryWithSquareBrackets:t.query)+")?(?:#"+t.fragment+")?",i=f.domain?t.relativeRefCapture:t.relativeRef;if(f.relativeOnly)return y.wrap(i+n);let s="";if(f.scheme){l(f.scheme instanceof RegExp||typeof f.scheme=="string"||Array.isArray(f.scheme),"scheme must be a RegExp, String, or Array");const r=[].concat(f.scheme);l(r.length>=1,"scheme must have at least 1 scheme specified");const a=[];for(let c=0;c<r.length;++c){const m=r[c];l(m instanceof RegExp||typeof m=="string","scheme at position "+c+" must be a RegExp or String"),m instanceof RegExp?a.push(m.source.toString()):(l(t.schemeRegex.test(m),"scheme at position "+c+" must be a valid scheme"),a.push(p(m)))}s=a.join("|")}const e="(?:"+(s?"(?:"+s+")":t.scheme)+":"+(f.domain?t.hierPartCapture:t.hierPart)+")",o=f.allowRelative?"(?:"+e+"|"+i+")":e;return y.wrap(o+n,s)},y.wrap=function(f,t){return{raw:f=`(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${f}`,regex:new RegExp(`^${f}$`),scheme:t}},y.uriRegex=y.createRegex({}),$.regex=function(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return f.scheme||f.allowRelative||f.relativeOnly||f.allowQuerySquareBrackets||f.domain?y.createRegex(f):y.uriRegex}},1447:(A,$)=>{const v={operators:["!","^","*","/","%","+","-","<","<=",">",">=","==","!=","&&","||","??"],operatorCharacters:["!","^","*","/","%","+","-","<","=",">","&","|","?"],operatorsOrder:[["^"],["*","/","%"],["+","-"],["<","<=",">",">="],["==","!="],["&&"],["||","??"]],operatorsPrefix:["!","n"],literals:{'"':'"',"`":"`","'":"'","[":"]"},numberRx:/^(?:[0-9]*(\.[0-9]*)?){1}$/,tokenRx:/^[\w\$\#\.\@\:\{\}]+$/,symbol:Symbol("formula"),settings:Symbol("settings")};$.Parser=class{constructor(l){let p=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!p[v.settings]&&p.constants)for(const y in p.constants){const f=p.constants[y];if(f!==null&&!["boolean","number","string"].includes(typeof f))throw new Error(`Formula constant ${y} contains invalid ${typeof f} value type`)}this.settings=p[v.settings]?p:Object.assign({[v.settings]:!0,constants:{},functions:{}},p),this.single=null,this._parts=null,this._parse(l)}_parse(l){let p=[],y="",f=0,t=!1;const n=s=>{if(f)throw new Error("Formula missing closing parenthesis");const e=p.length?p[p.length-1]:null;if(t||y||s){if(e&&e.type==="reference"&&s===")")return e.type="function",e.value=this._subFormula(y,e.value),void(y="");if(s===")"){const o=new $.Parser(y,this.settings);p.push({type:"segment",value:o})}else if(t){if(t==="]")return p.push({type:"reference",value:y}),void(y="");p.push({type:"literal",value:y})}else if(v.operatorCharacters.includes(y))e&&e.type==="operator"&&v.operators.includes(e.value+y)?e.value+=y:p.push({type:"operator",value:y});else if(y.match(v.numberRx))p.push({type:"constant",value:parseFloat(y)});else if(this.settings.constants[y]!==void 0)p.push({type:"constant",value:this.settings.constants[y]});else{if(!y.match(v.tokenRx))throw new Error(`Formula contains invalid token: ${y}`);p.push({type:"reference",value:y})}y=""}};for(const s of l)t?s===t?(n(),t=!1):y+=s:f?s==="("?(y+=s,++f):s===")"?(--f,f?y+=s:n(s)):y+=s:s in v.literals?t=v.literals[s]:s==="("?(n(),++f):v.operatorCharacters.includes(s)?(n(),y=s,n()):s!==" "?y+=s:n();n(),p=p.map((s,e)=>s.type!=="operator"||s.value!=="-"||e&&p[e-1].type!=="operator"?s:{type:"operator",value:"n"});let i=!1;for(const s of p){if(s.type==="operator"){if(v.operatorsPrefix.includes(s.value))continue;if(!i)throw new Error("Formula contains an operator in invalid position");if(!v.operators.includes(s.value))throw new Error(`Formula contains an unknown operator ${s.value}`)}else if(i)throw new Error("Formula missing expected operator");i=!i}if(!i)throw new Error("Formula contains invalid trailing operator");p.length===1&&["reference","literal","constant"].includes(p[0].type)&&(this.single={type:p[0].type==="reference"?"reference":"value",value:p[0].value}),this._parts=p.map(s=>{if(s.type==="operator")return v.operatorsPrefix.includes(s.value)?s:s.value;if(s.type!=="reference")return s.value;if(this.settings.tokenRx&&!this.settings.tokenRx.test(s.value))throw new Error(`Formula contains invalid reference ${s.value}`);return this.settings.reference?this.settings.reference(s.value):v.reference(s.value)})}_subFormula(l,p){const y=this.settings.functions[p];if(typeof y!="function")throw new Error(`Formula contains unknown function ${p}`);let f=[];if(l){let t="",n=0,i=!1;const s=()=>{if(!t)throw new Error(`Formula contains function ${p} with invalid arguments ${l}`);f.push(t),t=""};for(let e=0;e<l.length;++e){const o=l[e];i?(t+=o,o===i&&(i=!1)):o in v.literals&&!n?(t+=o,i=v.literals[o]):o!==","||n?(t+=o,o==="("?++n:o===")"&&--n):s()}s()}return f=f.map(t=>new $.Parser(t,this.settings)),function(t){const n=[];for(const i of f)n.push(i.evaluate(t));return y.call(t,...n)}}evaluate(l){const p=this._parts.slice();for(let y=p.length-2;y>=0;--y){const f=p[y];if(f&&f.type==="operator"){const t=p[y+1];p.splice(y+1,1);const n=v.evaluate(t,l);p[y]=v.single(f.value,n)}}return v.operatorsOrder.forEach(y=>{for(let f=1;f<p.length-1;)if(y.includes(p[f])){const t=p[f],n=v.evaluate(p[f-1],l),i=v.evaluate(p[f+1],l);p.splice(f,2);const s=v.calculate(t,n,i);p[f-1]=s===0?0:s}else f+=2}),v.evaluate(p[0],l)}},$.Parser.prototype[v.symbol]=!0,v.reference=function(l){return function(p){return p&&p[l]!==void 0?p[l]:null}},v.evaluate=function(l,p){return l===null?null:typeof l=="function"?l(p):l[v.symbol]?l.evaluate(p):l},v.single=function(l,p){if(l==="!")return!p;const y=-p;return y===0?0:y},v.calculate=function(l,p,y){if(l==="??")return v.exists(p)?p:y;if(typeof p=="string"||typeof y=="string"){if(l==="+")return(p=v.exists(p)?p:"")+(v.exists(y)?y:"")}else switch(l){case"^":return Math.pow(p,y);case"*":return p*y;case"/":return p/y;case"%":return p%y;case"+":return p+y;case"-":return p-y}switch(l){case"<":return p<y;case"<=":return p<=y;case">":return p>y;case">=":return p>=y;case"==":return p===y;case"!=":return p!==y;case"&&":return p&&y;case"||":return p||y}return null},v.exists=function(l){return l!=null}},9926:()=>{},5688:()=>{},9708:()=>{},1152:()=>{},443:()=>{},9848:()=>{},5934:A=>{A.exports={version:"17.9.1"}}},O={},function A($){var v=O[$];if(v!==void 0)return v.exports;var l=O[$]={exports:{}};return k[$](l,l.exports,A),l.exports}(5107);var k,O})})(he);var Ge=he.exports;const z=ge(Ge);function Ze(x,j){const k=x.validate(j);return k.error?k:null}const de=z.alternatives().try(z.string().pattern(/^0x[0-9a-fA-F]+$/),z.number().positive()),pe=z.string().valid("evm"),Ke=z.object({address:z.string().required(),icon:z.string().optional()}),Ye=z.object({namespace:pe,id:de.required(),rpcUrl:z.string(),label:z.string(),token:z.string(),secondaryTokens:z.array().max(5).items(Ke).optional(),icon:z.string(),color:z.string(),publicRpcUrl:z.string(),protectedRpcUrl:z.string(),blockExplorerUrl:z.string()}),ot=Object.freeze(Object.defineProperty({__proto__:null,InterVar:ve,ProviderRpcError:Q,get ProviderRpcErrorCode(){return X},bigIntToHex:Ve,chainIdToViemImport:We,chainIdValidation:de,chainNamespaceValidation:pe,chainValidation:Ye,createDownloadMessage:He,createEIP1193Provider:ye,ethToWeiBigInt:Be,fromHex:K,isAddress:fe,isHex:ee,parseEther:me,toHex:Ie,validate:Ze,weiHexToEth:Fe,weiToEth:Ue},Symbol.toStringTag,{value:"Module"}));export{je as A,F as B,ke as C,Ae as D,oe as E,Me as F,ze as G,K as H,rt as I,Se as J,Oe as K,xe as L,me as M,ot as N,et as S,Z as a,Re as b,Y as c,nt as d,ne as e,Pe as f,at as g,te as h,ee as i,ue as j,le as k,$e as l,De as m,re as n,Te as o,H as p,V as q,Qe as r,Le as s,Ie as t,Xe as u,tt as v,st as w,qe as x,ce as y,it as z};
